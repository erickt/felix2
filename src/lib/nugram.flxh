
SCHEME """
(begin
  (define (first x)(car x))
  (define (second x)(cadr x))
  (define (third x)(caddr x))
  (define (tail x)(cdr x))
)
""";

SCHEME """
(define fold_left
  (lambda (f acc lst)
    (if (null? lst) acc (fold_left f (f acc (first lst)) (tail lst)))))
""";

SCHEME """
(define (mkname x)`(ast_name ,_sr ,x ()))
""";

SCHEME """
(define (typesoftvarlist x) (map mkname (map first (first x))))
""";

SCHEME """
(define dfltaux '( (ast_tuple ("dummy" 0 0 0 0) ()) ()))
""";

SCHEME """
(define dfltvs
  `(
    ()           ;; vs list: name,type,constraint triple
    ,dfltaux
  )
)
""";

SCHEME """
  (define dfltargs '((() none)))
""";

SCHEME """
  (define (lazy stmts) `(ast_lambda (,dfltvs ,dfltargs typ_none ,stmts)))
""";

SCHEME """
  (define (lazy_proc stmts) `(ast_lambda (,dfltvs ,dfltargs ast_void ,stmts)))
""";

SCHEME """
  (define (block stmts)`(ast_call ,_sr ,(lazy_proc stmts) ())))
""";

SCHEME """
  (define call (lambda (f a) `(ast_call ,_sr (ast_name ,_sr ,f ()) ,a)))
""";

SCHEME """
(define (splitapply x)
  (if (pair? x)
    (if (eq? (first x) 'ast_apply)
      (if (pair? (cddr x))
        (begin
;;           (display "f=")(display (caaddr x))
;;           (display " arg=")(display (cadaddr x))
;;           (display " pair=")(display (caddr x))
           (caddr x))
        (list x ()))
      (list x ()))
    (list ()))
)
""";

SCHEME """
(define (mkl x)
  (begin
  ;;(display "mkl x=")(display x)
  (if (pair? x)
    (if (eq? (first x) 'ast_tuple)
      (if (pair? (cddr x)) (caddr x) (list x))
      (list x))
    (list x)))
)
""";

SCHEME """
(define (mkl2 x)
  (begin
  ;;(display "mkl2 x=")(display x)
  (if (pair? x)
    (if (eq? (first x) 'ast_product)
      (if (pair? (cddr x)) (caddr x) (list x))
      (list x))
    (list x)))
)
""";

SCHEME """
(define (cal_funkind adjs fk)
  (if (eq? fk 'CFunction)'CFunction
  (if (eq? fk 'Generator)'Generator
  ;; fk is Function
  (if (pair? adjs)(first adjs)'Function
))))
""";

SCHEME """
(define (myassoc elt alst)
  (let ((r (assoc elt alst)))
  (if r (second r) `(MISMATCHED_BRACKET ,elt ,alst))))
""";

SCHEME """
(define (tvfixup_folder vsct vtc)
  (begin ;;(display "tvfixup_folder vsct=")(display vsct)(display ", vtc=")(display vtc)(display "\\n")
  (let*
    (
      (vs (first vsct))
      (ct (second vsct))
      (v (first vtc))
      (t (second vtc))
      (c (caddr vtc))
      (ct2
        (cond
          ((eq? 'NoConstraint c) ct )
          ((eq? 'Eq (first c)) ;; type constraint
            `(ast_intersect
              ((ast_type_match ((ast_name ,_sr ,v ()) ((,(second c) ()))))
              ,ct)
            )
          )
          ((eq? 'In (first c)) ;; type constraint
            `(ast_intersect
              ((ast_isin ((ast_name ,_sr ,v ()) ,(second c)))
              ,ct)
            )
          )
        (else (display "ERROR!!!"))
        )
      )
    )
    (begin
    ;;  (display "vs=")(display vs)
    ;;  (display "\\nct=")(display ct)
    ;;  (display "\\nv=")(display v)
    ;;  (display "\\nt=")(display t)
    ;;  (display "\\nc=")(display c)
    ;;  (display "\\nct2=")(display ct2)
    ;;  (display "\\n")
    (list (cons `(,v ,t) vs) ct2))
))))
""";

//
// rti = rtc:type constraint, rtr:typeclass requirement list
//

SCHEME """
(define (tvfixup tv ct)
  (begin ;;(display "tvfixup tv=")(display tv)(display ", ct=")(display ct)(display "\\n")
  (let*
    (
      (vscs (fold_left tvfixup_folder `(() (ast_tuple ,_sr ())) tv))
      (vs (first vscs))
      (cs (second vscs))
      (rtc (first ct))
      (rtr (second ct))
      (ct `((ast_intersect (,rtc ,cs)) ,rtr))
    )
    (begin
    ;;  (display "vs=")(display vs)
    ;;  (display "\\ncs=")(display cs)
    ;;  (display "\\nrtc=")(display rtc)
    ;;  (display "\\nrtr=")(display rtr)
    ;;  (display "\\nct=")(display ct)
    ;;  (display "\\n")
    (list (reverse vs) ct))
  )
))
""";

SCHEME """
  (define (maybe k)(if (null? k)'none `(some ,(first k))))
""";

SCHEME """
  (define (strap a b)
  (if(null? b)a(if(equal? b "")a(if(equal? a "")b(string-append a " " b)))))
""";

SCHEME """
  (define (strcat ls)(fold_left strap "" ls))
""";

// chain 'and (x) yields just x,
// chain 'and (x y) yields ('and _sr (x y))
SCHEME """
  (define (chain op hd tl)
    (
      if (equal? tl ())
      hd
      `(,op ,_sr ,(cons hd (map second tl)))
    )
  )
""";

SCHEME """
  (define (infix op) `(ast_apply ,_sr (,op (,_1 ,_3))))
""";
SCHEME """
  (define (prefix op) `(ast_apply ,_sr (,op ,_2)))
""";


//------------------------------------------
syntax expressions {
  /* Experimentally, start coding up for priority management */
  priority 
    let_pri < 
    slambda_pri <
    sdollar_apply_pri < 
    stuple_pri <
    sor_condition_pri <
    sand_condition_pri <
    snot_condition_pri <
    scomparison_pri <
    sas_expr_pri <
    ssetunion_pri <
    ssetintersection_pri <
    sarrow_pri <
    scase_literal_pri <
    sbor_pri <
    sbxor_pri <
    sband_pri <
    sshift_pri <
    ssum_pri <
    ssubtraction_pri <
    sproduct_pri <
    s_term_pri <
    sprefixed_pri <
    spower_pri <
    ssuperscript_pri <
    srefr_pri <
    sapplication_pri <
    scoercion_pri <
    sfactor_pri 
  ;

  sexpr := x[let_pri] =># "_1";
  stypeexpr:= x[sor_condition_pri] =># "_1";

  x[let_pri] := "let" spattern = x[let_pri] "in" x[let_pri] =># "`(ast_letin (,_2 ,_4 ,_6))";

  x[sdollar_apply_pri] := x[stuple_pri] "unless" x[let_pri] "then" x[sdollar_apply_pri] =>#
    "`(ast_cond ((ast_apply ,_sr (lnot ,_3)) ,_1 ,_5))";
  x[sdollar_apply_pri] := x[stuple_pri] "$" x[sdollar_apply_pri] =># "`(ast_apply ,_sr (,_1 ,_3))";

  x[stuple_pri] := x[>stuple_pri] ( , x[>stuple_pri])+ =># "(chain 'ast_tuple _1 _2)";
  x[sor_condition_pri] := x[>sor_condition_pri] ( "or" x[>sor_condition_pri])+ =># "(chain 'ast_orlist _1 _2)" note "lor";
  x[sand_condition_pri] := x[>sand_condition_pri] ( "and" x[>sand_condition_pri])+ =># "(chain 'ast_andlist _1 _2)" note "land";
  x[snot_condition_pri] := "not" x[snot_condition_pri]  =># "(prefix 'lnot)";

  x[scomparison_pri]:= x[>scomparison_pri] < x[>scomparison_pri] =># "(infix 'lt)";
  x[scomparison_pri]:= x[>scomparison_pri] <= x[>scomparison_pri] =># "(infix 'le)";
  x[scomparison_pri]:= x[>scomparison_pri] == x[>scomparison_pri] =># "(infix 'eq)";
  x[scomparison_pri]:= x[>scomparison_pri] != x[>scomparison_pri] =># "(infix 'ne)";
  x[scomparison_pri]:= x[>scomparison_pri] >= x[>scomparison_pri] =># "(infix 'ge)";
  x[scomparison_pri]:= x[>scomparison_pri] > x[>scomparison_pri] =># "(infix 'gt)";

  x[sas_expr_pri] := x[sas_expr_pri] "as" sname =># "`(ast_as (,_1 ,_3))";

  x[ssetunion_pri] := x[>ssetunion_pri] ( "||" x[>ssetunion_pri])+ =># "(chain 'ast_setunion _1 _2)" note "setunion";
  x[ssetintersection_pri] := x[>ssetintersection_pri] ("&&" x[>ssetintersection_pri])+ =># "(chain 'ast_setintersection _1 _2)" note "setintersection";
  x[sarrow_pri] := x[scase_literal_pri] "->" x[sarrow_pri] =># "`(ast_arrow (,_1 ,_3))";
  x[sarrow_pri] := x[scase_literal_pri] "-->" x[sarrow_pri] =># "`(ast_longarrow (,_1 ,_3))";
  x[scase_literal_pri] := "case" sinteger =># "`(ast_case_tag ,_2))";
  x[scase_literal_pri] := "case" sinteger "of" x[ssum_pri] =># "`(ast_typed_case ,_2 ,_4)";
  x[scase_literal_pri] := "case" sname "of" x[ssum_pri] =># "`(ast_variant (,_2 ,_4))";

  x[sbor_pri] := x[sbor_pri] "\\|" x[>sbor_pri] =># "(infix 'bor)";
  x[sbxor_pri] := x[sbxor_pri] "\\^" x[>sbxor_pri] =># "(infix 'bxor)";
  x[sband_pri] := x[sband_pri] "\\&" x[>sband_pri] =># "(infix 'band)";
  x[sshift_pri] := x[sshift_pri] "<<" x[>sshift_pri] =># "(infix 'shl)";
  x[sshift_pri] := x[sshift_pri] ">>" x[>sshift_pri] =># "(infix 'shr)";

  x[ssum_pri] := x[>ssum_pri] (plus x[>ssum_pri])+ =># "(chain 'ast_sum _1 _2)" note "add";
  x[ssubtraction_pri] := x[ssubtraction_pri] "-" x[sproduct_pri] =># "(infix 'sub)";

  x[sproduct_pri] := x[>sproduct_pri] (star x[>sproduct_pri])+ =># "(chain 'ast_product _1 _2)" note "mul";

  x[s_term_pri] := x[s_term_pri] "/" x[>s_term_pri] =># "(infix 'div)";
  x[s_term_pri] := x[s_term_pri] "%" x[>s_term_pri] =># "(infix 'mod)";

  x[sprefixed_pri] := "!" x[spower_pri] =># "(prefix 'excl)";
  x[sprefixed_pri] := plus x[spower_pri] =># "(prefix 'pos)";
  x[sprefixed_pri] := "-" x[spower_pri] =># "(prefix 'neg)";
  x[sprefixed_pri] := "~" x[spower_pri] =># "(prefix 'bnot)";

  x[spower_pri] := x[ssuperscript_pri] "**" x[sprefixed_pri] =># "(infix 'pow)";
  x[ssuperscript_pri] := x[ssuperscript_pri] "^" x[srefr_pri] =># "`(ast_superscript (,_1 ,_3))";

  x[srefr_pri] := "&" x[srefr_pri] =># "`(ast_ref ,_2)";
  x[srefr_pri] := star x[srefr_pri] =># "(prefix 'deref)";
  x[srefr_pri] := "_deref" x[srefr_pri] =># "`(ast_deref ,_2)";
  x[srefr_pri] := "new" x[srefr_pri] =># "`(ast_new ,_2)";
  x[srefr_pri] := anon_value =># "_1";

  anon_value := "struct" lbrace sstruct_mem_decl* rbrace =># "`(ast_record_type ,_3)";
  anon_value := lpar sstruct_mem_decl+ rpar =># "`(ast_record_type ,_2)";
  sstruct_mem_decl := sname ":" stypeexpr ";" =># "`(,_1 ,_3)";

  anon_value := "struct" lbrace sstruct_assign* rbrace =># "`(ast_record ,_3)";
  anon_value := lpar sstruct_assign+ rpar =># "`(ast_record ,_2)";
  sstruct_assign := sname = sexpr ";" =># "`(,_1 ,_3)";

  anon_value := "union" lbrace stype_sum_item0* rbrace =># "`(ast_variant_type ,_3)";
  stype_sum_item := sname sopt_value stvarlist "of" sexpr =># "`(,_1 ,_2 ,_3 ,_5)";
  stype_sum_item := sname sopt_value stvarlist =># "`(,_1 ,_2 ,_3 ast_void)";

  stype_sum_item0 := sname "of" sexpr =># "`(,_1 none ,_3)";
  stype_sum_item0 := sname =># "`(,_1 none ast_void)";

  stype_sum_item1 := stype_sum_item ";" =># "_1";

  stype_sum_item2 := vbar stype_sum_item =># "_2";
  stype_sum_items2 := stype_sum_item stype_sum_item2* =># "(cons _1 _2)";
  stype_sum_items2 := stype_sum_item2* =># "_1";

  x[sapplication_pri] := x[sapplication_pri] x[scoercion_pri] =># "`(ast_apply ,_sr (,_1 ,_2))" note "apply";
  x[sapplication_pri] := "caseno" x[scoercion_pri] =># "`(ast_case_index ,_2)";
  x[sapplication_pri] := "likely" x[scoercion_pri] =># "`(ast_likely ,_2)";
  x[sapplication_pri] := "unlikely" x[scoercion_pri] =># "`(ast_unlikely ,_2)";

  x[scoercion_pri] := x[scoercion_pri] ":" x[sfactor_pri] =># "`(ast_coercion (,_1 ,_3))";
  x[scoercion_pri] := ssuffixed_name =># "_1";

  x[sfactor_pri] := shash_name =># "_1";
  x[sfactor_pri] := x[sfactor_pri] "." lsqb sexpr rsqb =># "`(ast_apply ,_sr (subscript (,_1 ,_4)))";
  x[sfactor_pri] := x[sfactor_pri] "." lsqb sexpr k"to" sexpr rsqb =># "`(ast_apply ,_sr (substring (,_1 ,_4 ,_6)))";
  x[sfactor_pri] := x[sfactor_pri] "." lsqb sexpr k"to" rsqb =># "`(ast_apply ,_sr (copyfrom (,_1 ,_4)))";
  x[sfactor_pri] := x[sfactor_pri] "." lsqb k"to" sexpr rsqb =># "`(ast_apply ,_sr (copyto (,_1 ,_5)))";
  x[sfactor_pri] := x[sfactor_pri] "." shash_name =># "`(ast_dot ,_sr (,_1 ,_3))))";
  // note the next production MUST be after the previous one so it overrides the
  // interpretation of a.(0) as an AST_dot
  x[sfactor_pri] := x[sfactor_pri] "." lpar sinteger rpar =># "`(ast_get_n (,_4 ,_1))";

  // these are weirdos
  sbasic_name_comma_list:= sname (, sname)* =># "(cons _1 (map second _2))";

  squalified_name_comma_list:= squalified_name (, squalified_name)* =># "(cons _1 (map second _2))";

  shash_name := "#" shash_name =># "`(ast_lift ,_2)";
  shash_name := sthe_name =># "_1";

  sthe_name :=
    | "the" squalified_name =># "`(ast_the ,_2)"
    | "noexpand" squalified_name =># "`(ast_noexpand ,_2)"
    | quest sname =># "`(ast_patvar ,_2)"
    | squalified_name =># "_1"
  ;
  sthe_name := satom =># "_1";

  squalified_name := squalified_name "::" ssimple_name_parts =>#
    "`(ast_lookup (,_1 ,(first _3) ,(second _3)))";
  squalified_name := ssimple_name_parts =>#
    "`(ast_name ,_sr ,(first _1) ,(second _1))";
  ssuffixed_name := squalified_name "of" x[sfactor_pri] =>#
    "`(ast_suffix (,_1 ,_3))";

  ssimple_name_parts := sname =># "`(,_1 ())";
  ssimple_name_parts := sname lsqb sexpr rsqb =># "`(,_1 ,(mkl _3))";

  satom := lpar rassign (, rassign )* rpar =>#
    "`(ast_record ,(cons _2 (map second _3)))"
  ;
  rassign := sname = x[sor_condition_pri] =># "`(,_1 ,_3)";

  satom := sliteral =># "_1";
  satom := _ =># "'ast_patany";
  satom := "..." =># "'ast_ellipsis";
  satom := "false" =># "'(ast_typed_case  0 2)";
  satom := "true" =># "'(ast_typed_case  1 2)";

  satom := "callback" lsqb sexpr rsqb =># "`(ast_callback ,_3)";
  satom := "[|" sexpr "|]" =># "`(ast_arrayof ,(mkl _2))";
  satom := lbrace sexpr rbrace =># "(lazy `((ast_fun_return ,_sr ,_2)))";

  satom := scompound =># "(lazy _1)";

  satom := lpar sexpr rpar =># "_2";
  satom := lpar rpar =># "'()";
  satom := sconditional =># "_1";

  sconditional := "if" sexpr "then" sexpr selse_part "endif" =>#
    "`(ast_cond (,_2 ,_4 ,_5))";

    selif := "elif" sexpr "then" sexpr =># "`(,_2 ,_4)";

    selifs := selif =># "`(,_1)";
    selifs := selifs selif =># "(cons _2 _1)";

    selse_part:= "else" sexpr =># "_2";
    selse_part:= selifs "else" sexpr =>#
        """
          (let ((f (lambda (result condthn)
            (let ((cond (first condthn)) (thn (second condthn)))
              `(ast_cond (,cond ,thn ,result))))))
          (fold_left f _3 _1))
        """;
}

//------------------------------------------
syntax patterns {
  satom := pattern_match =># "_1";

  sexecutable := "match" sexpr "with" stmt_matching+ "endmatch" ";" =>#
    "`(ast_stmt_match (,_2 ,_4))";

  stmt_matching  := vbar spattern "=>" tstatement+ =># "`(,_2 ,_4)";

  pattern_match := "match" sexpr "with" smatching+ "endmatch" =>#
    "`(ast_match (,_2 ,_4))";

  smatching  := vbar spattern "=>" sexpr =># "`(,_2 ,_4)";
  smatching  := vbar "=>" sexpr =># "`(pat_none ,_4)";

  spattern := sas_pattern "when" sexpr =># "`(pat_when ,_1 ,_3)";
  spattern := sas_pattern =># "_1";

  sas_pattern := stuple_pattern "as" sname =># "`(pat_as ,_1 ,_3)";
  sas_pattern := stuple_pattern =># "_1";

  stuple_pattern := scoercive_pattern (, scoercive_pattern )* =># "(chain 'pat_tuple _1 _2)";

  scoercive_pattern := satomic_pattern "|>" x[sarrow_pri] =># "`(pat_coercion ,_1 ,_3)";
  scoercive_pattern := satomic_pattern =># "_1";

  satomic_pattern := "true" =># "'(pat_const_ctor (ast_case_tag 1))";
  satomic_pattern := "false" =># "'(pat_const_ctor (ast_case_tag 0))";
  satomic_pattern := sstring =># "`(pat_string ,_1)";
  satomic_pattern := quest sname =># "`(pat_as pat_any ,_2)";
  satomic_pattern := _ =># "'pat_any";
  satomic_pattern := lpar spattern rpar =># "_2";
  satomic_pattern := "struct" lbrace spat_assign+ rbrace =># "`(pat_record ,_3)";

  spat_assign := sname = spattern ";" =># "`(,_1 ,_3)";

  satomic_pattern := sctor_name satomic_pattern =># "`(pat_nonconst_ctor ,_1 ,_2)";
  satomic_pattern := sctor_name =># "`(pat_const_ctor ,_1)";

  sctor_name := squalified_name =># "_1";
  sctor_name := "case" sinteger =># "`(ast_case_tag ,_2)";

  satomic_pattern := sstring ".." sstring =># "`(pat_string_range ,_1 ,_3)";
  satomic_pattern := sintegral =># "`(pat_int ,(first _1) ,(second _1))";
  satomic_pattern := sintegral ".." sintegral=>#
    "`(pat_int_range ,(first _1) ,(second _1) ,(first _3) ,(second _3))";

  satomic_pattern := "NaN" =># "'pat_nan";
  satomic_pattern := sfloating ".." sfloating =>#
    "`(pat_float_range ,_1 ,_3)";

  sfloating:= sfloat =># "`(Float_plus ,(first _1) ,(second _1))";
  sfloating:= "-" sfloat =># "`(Float_minus ,(first _2) ,(second _2))";
  sfloating:= "inf" =># "'Float_inf";
  sfloating:= "-" "inf" =># "'Float_minus_inf";
}

//------------------------------------------
syntax functions {
  requires expressions;
  sdeclarative := sfunction_definition =># "_1";
  sdeclarative := sprocedure_definition =># "_1";
  sdeclarative := sctor_definition =># "_1";

  x[slambda_pri] := sadjectives "fun" stvarlist slambda_fun_args fun_return_type = scompound =>#
    """
    `(ast_lambda (,_3 ,_4 ,(first _5) ,_7))
    """;

  x[slambda_pri] := sadjectives "fun" stvarlist slambda_fun_args fun_return_type "=>" sexpr =>#
    """
    `(ast_lambda (,_3 ,_4 ,(first _5) ((ast_fun_return ,_sr ,_7))))
    """;

  x[slambda_pri] := sadjectives "proc" stvarlist slambda_fun_args scompound =>#
    """
    `(ast_lambda (,_3 ,_4 ast_void ,_5))
    """;

  x[slambda_pri] := sadjectives "proc" stvarlist scompound =>#
    """
    `(ast_lambda (,_3 ((() none)) ast_void ,_4))
    """;

  sadjective := k"inline" =># "'InlineFunction";
  sadjective := k"noinline" =># "'NoInlineFunction";
  sadjective := k"static" =># "'InlineFunction";
  sadjective := k"extern" =># "'NoInlineFunction";
  sadjective := k"virtual" =># "'Virtual";
  sadjective := k"lvalue" =># "'Lvalue";
  sadjectives := sadjective* =># "_1";

  slambda_fun_arg := lpar sparameter_comma_list "when" sexpr rpar =># "`(,_2 (some ,_4))";
  slambda_fun_arg := lpar sparameter_comma_list rpar =># "`(,_2 none)";
  slambda_fun_args := slambda_fun_arg+ =># "_1";

  fun_return_type := ":" stypeexpr "expect" sexpr =># "`(,_2 (some ,_4))";
  fun_return_type := ":" stypeexpr =># "`(,_2 none)";
  fun_return_type := "expect" sexpr =># "`(typ_none (some ,_2))";
  fun_return_type := sepsilon =># "'(typ_none none)";

  sparameter := sparam_qual sname ":" x[sarrow_pri] = x[sor_condition_pri] =># "`(,_1 ,_2 ,_4 (some ,_6))";
  sparameter := sparam_qual sname ":" x[sarrow_pri] =># "`(,_1 ,_2 ,_4 none)";
  sparameter := sparam_qual sname =># "`(,_1 ,_2 typ_none none)";

  sparameter_comma_list := sepsilon =># "()";
  sparameter_comma_list := sparameter (, sparameter)* =># "(cons _1 (map second _2))";

  sparam_qual := "val" =># "'PVal";
  sparam_qual := "var" =># "'PVar";
  sparam_qual := "ref" =># "'PRef";
  sparam_qual := "fun" =># "'PFun";
  sparam_qual := sepsilon =># "'PVal";

  sfun_arg :=  lpar sparameter_comma_list "when" sexpr rpar =># "`(,_2 (some ,_4))";
  sfun_arg :=  lpar sparameter_comma_list rpar =># "`(,_2 none)";
  sfun_arg :=  sname =># "`(((PVal ,_1 typ_none none)) none)";

  sfun_kind := "cfun" =># "'CFunction";
  sfun_kind := "gen" =># "'Generator";
  sfun_kind := "fun" =># "'Function";

  sfunction_definition := sadjectives sfun_kind sdeclname sfun_arg* fun_return_type "=>" sexpr ";" =>#
    """
      (let ((body `((ast_fun_return ,_sr ,_7))))
      `(ast_curry ,_sr ,(first _3) ,(second _3) ,_4 ,_5 ,(cal_funkind _1 _2) ,body)
      )
    """;

  sfunction_definition := sadjectives sfun_kind sdeclname sfun_arg* fun_return_type = scompound =>#
    """
      `(ast_curry ,_sr ,(first _3) ,(second _3) ,_4 ,_5 ,(cal_funkind _1 _2) ,_7)
    """;

  sopt_cstring := = scode_spec =># "`(some ,_2)";
  sopt_cstring := sepsilon =># "'none";

  sfunction_definition := sadjectives sfun_kind sdeclname fun_return_type = smatching+ ";" =>#
    """
     (let
       (
        (t (first _4))
        (traint (second _4))
       )
      (begin ;;(display "ftype=")(display t)(display "\\n")
      (if (eq? 'ast_arrow (first t))
        (let
          (
            (argt (caadr t))
            (ret (cadadr t))
            (body `((ast_fun_return ,_sr (ast_match (_a ,_6)))))
          )
          `(ast_curry ,_sr ,(first _3) ,(second _3)
            (
              (((PVal _a ,argt none)) none)
            )
            (,ret ,traint)
            ,(cal_funkind _1 _2) ,body)
        )
        'ERROR
       )
       )
     )
    """;

  sproc_kind := "proc" =># "'Function";
  sproc_kind := "cproc" =># "'CFunction";

  sopt_traint_eq:= "expect" sexpr = =># "`(some ,_2)";
  sopt_traint_eq:= = =># "'none";
  sopt_traint_eq:= sepsilon =># "'none";

  sopt_traint:= "expect" sexpr =># "`(some ,_2)";
  sopt_traint:= sepsilon =># "'none";

  sctor_init := sname lpar sexpr rpar =># "`(,_1 ,_3)";
  sctor_inits := ":" sctor_init (, sctor_init)* =># "(cons _2 _3)";
  sctor_inits := sepsilon =># "()";

  // only used by classes
  sctor_definition := "ctor" stvarlist sfun_arg* sopt_traint_eq sctor_inits scompound =>#
    """
    (let*
      (
        (name "__constructor__")
        (vs _2)
        (ret 'ast_void)
        (traint _4)
        (body _6)
        (inits _5)
        (args _3)
        (f (lambda (ne)`(ast_init ,_sr ,(first ne) ,(second ne))))
        (body (append (map f inits) body))
      )
      `(ast_curry ,_sr ,name ,vs ,args (,ret ,traint) Ctor ,body))
    """;

  sctor_definition := "ctor" stvarlist sname sfun_arg+ sopt_traint_eq scompound =>#
    """
    (let*
      (
        (name (string-append "_ctor_" _3))
        (vs _2)
        (ret `(ast_name ,_sr ,_3 ()))
        (traint _5)
        (body _6)
        (args _4)
      )
      `(ast_curry ,_sr ,name ,vs ,args (,ret ,traint) Function ,body))
    """;

  sctor_definition := "ctor" stvarlist sname sfun_arg+ sopt_traint "=>" sexpr ";" =>#
    """
    (let*
      (
        (name (string-append "_ctor_" _3))
        (vs _2)
        (ret `(ast_name ,_sr ,_3 ,(typesoftvarlist _2)))
        (traint _5)
        (body `((ast_fun_return ,_sr ,_7)))
        (args _4)
      )
      `(ast_curry ,_sr ,name ,vs ,args (,ret ,traint) Function ,body))
    """;

  sprocedure_definition := sadjectives sproc_kind sdeclname sfun_arg* sopt_traint_eq scompound =>#
    """
      `(ast_curry ,_sr ,(first _3) ,(second _3) ,_4 (ast_void ,_5) ,(cal_funkind _1 _2) ,_6)
    """;

  sprocedure_definition := sadjectives sproc_kind sdeclname sfun_arg* "=>" tstatement =>#
    """
      `(ast_curry ,_sr ,(first _3) ,(second _3) ,_4 (ast_void none) ,(cal_funkind _1 _2) (,_6))
    """;
}

//------------------------------------------
syntax statements {
  requires expressions;
  tstatement:= sexecutable=># "_1";
  tstatement:= sdeclarative =># "_1";
  tstatement:= sinclusion =># "_1";
  tstatement:= sdirective =># "_1";
  tstatement:= spublish =># "_1";
  tstatement:= scomment =># "_1";
  tstatement:= snull_statement =># "_1";
  scomment := "comment" sstring ";" =># "`(ast_comment ,_sr ,_2)";

  spublish := "private" sdeclarative =># "`(ast_private ,_2)";
  spublish := "private" sbinding_definition =># "`(ast_private ,_2)";
  spublish := "private" svar_def =># "`(ast_private ,_2)";
  spublish := "private" sval_def =># "`(ast_private ,_2)";

  spublish := "publish" sstring tstatement =># "_3";

  sdeclarative := smodule_definition =># "_1";
  sdeclarative := sunion_decl =># "_1";
  sdeclarative := sstruct_decl =># "_1";
  sdeclarative := stype_alias =># "_1";

  sdirective := sopen_decl =># "_1";

  snull_statement := ";" =># """`(ast_nop ,_sr "")""";

  sinclusion := "include" sstring ";" =># "`(ast_include ,_sr ,_2)";

  // note: list is reversed, eg X::Y::name goes to list name, Y, Z
  sdeclname := sname stvarlist =># "`(,_1 ,_2)";

  sabstract_type := stype_qual* "type" sdeclname = "new" sexpr ";" =>#
    """
    `(ast_newtype ,_sr ,(first _3) ,(second _3) ,_6)
    """;

  stype_constraint := "with" squalified_name_comma_list "where" sexpr =>#
    "`(,_4 ,_2)";
  stype_constraint := "where" sexpr "with" squalified_name_comma_list =>#
    "`(,_2 ,_4)";
  stype_constraint := "where" sexpr =># "`(,_2 ())";
  stype_constraint := "with" squalified_name_comma_list =># "`((ast_tuple,_sr()) ,_2)";
  stype_constraint := sepsilon =># "`((ast_tuple,_sr())())";

  seqorin:= = stypeexpr =># "`(Eq ,_2)";
  seqorin:= "in" stypeexpr =># "`(In ,_2)";
  seqorin:= sepsilon =># "'NoConstraint";

  stvar := sname seqorin =># """`(,_1 (ast_name ,_sr "TYPE" ()) ,_2)""";
  stvar := sname ":" stypeexpr seqorin =># "`(,_1 ,_3 ,_4)";

  stvar_comma_list := stvar scomma_tvar* =># "(cons _1 _2)";
  stvar_comma_list := sepsilon =># "'()";
  scomma_tvar := , stvar =># "_2";

  stvarlist:= sepsilon =># "dfltvs";
  stvarlist:= lsqb stvar_comma_list stype_constraint rsqb =>#
    "(tvfixup _2 _3)";

  stypeparameter:= sname ":" x[sarrow_pri] =># "`(,_1 ,_3)";
  stypeparameter:= sname =># "`(,_1 typ_none)";
  stypeparameter_comma_list := sepsilon =># "()";
  stypeparameter_comma_list := stypeparameter , stypeparameter_comma_list =># "(cons _1 _3)";
  stypeparameter_comma_list := stypeparameter =># "`(,_1)";

  stypefun_arg := sname =># "`((,_1 typ_none))";
  stypefun_arg := lpar stypeparameter_comma_list rpar =># "_2";
  stypefun_args := stypefun_arg+  =># "_1";

  stodo := "todo" sstring ";" =># "`(ast_nop ,_sr ,_2)";
  stodo := "todo" ";" =># """`(ast_nop ,_sr "todo")""";

  //scompound := lbrace sstatements rbrace =># "_2";
  scompound := lbrace tstatement* rbrace =># "_2";

  sname_suffix:= comma sname sname_suffix =># "(cons _2 _3)";
  sname_suffix:= comma sname =># "`(,_2)";
}

//------------------------------------------
syntax variables {
  // assignments have lower priority than variable
  // definitions to support 'int x = 1;' being
  // a variable definition "not" an assignment,
  // so we have to requires them first: they're
  // currently defined in executable.. this is fragile ..
  requires statements, executable;

  sexecutable := svar_def =># "_1";
  sexecutable := sval_def =># "_1";
  sval_def := "val" sname sname_suffix = sexpr ";" =>#
    """
    (let
      (
        (names (cons _2 _3))
        (vals (mkl _5))
      )
      (begin
      ;;(display "names=")(display names)
      ;;(display "init=")(display vals)
      ;;(display "\\n")
      (if (eq? (length names)(length vals))
        (let
          (
            (f (lambda (n v)`(ast_val_decl ,_sr ,n ,dfltvs none (some ,v))))
          )
          `(ast_seq ,_sr ,(map f names vals))
        )
        (let*
          (
            (f (lambda (n)`((Val ,_sr ,n) none)))
            (lexpr (map f names))
          )
          `(ast_assign ,_sr _set ((List ,lexpr) none) ,_5)
        )
    )))
    """;

  sval_def := "val" sdeclname = sexpr ";" =>#
    """
    `(ast_val_decl ,_sr ,(first _2) ,(second _2) none (some ,_4))
     """;

  sval_def := "val" sdeclname ":" stypeexpr = sexpr ";" =>#
    """
    `(ast_val_decl ,_sr ,(first _2) ,(second _2) (some ,_4) (some ,_6))
     """;

  sval_def := "val" sdeclname ":" stypeexpr ";" =>#
    """
    `(ast_val_decl ,_sr ,(first _2) ,(second _2) (some ,_4) none)
     """;

  sval_def := "ref" sdeclname "<-" sexpr ";" =>#
    """
    `(ast_ref_decl ,(first _2) ,(second _2) none (some ,_4))
     """;

  sval_def := "ref" sdeclname ":" stypeexpr "<-" sexpr ";" =>#
    """
    `(ast_ref_decl ,(first _2) ,(second _2) (some ,_4) (some ,_6))
     """;

  sval_def := "fun" sdeclname "<-" sexpr ";" =>#
    """
    `(ast_lazy_decl ,(first _2) ,(second _2) none (some ,_4))
     """;

  sval_def := "fun" sdeclname ":" stypeexpr "<-" sexpr ";" =>#
    """
    `(ast_lazy_decl ,(first _2) ,(second _2) (some ,_4) (some ,_6))
     """;

  svar_def := "var" sname sname_suffix = sexpr ";" =>#
    """
    (let
      (
        (names (cons _2 _3))
        (vals (mkl _5))
      )
      (begin
      ;;(display "names=")(display names)
      ;;(display "init=")(display vals)
      ;;(display "\\n")
      (if (eq? (length names)(length vals))
        (let
          (
            (f (lambda (n v)`(ast_var_decl ,_sr ,n ,dfltvs none (some ,v))))
          )
          `(ast_seq ,_sr ,(map f names vals))
        )
        (let*
          (
            (f (lambda (n)`((Var ,_sr ,n) none)))
            (lexpr (map f names))
          )
          `(ast_assign ,_sr _set ((List ,lexpr) none) ,_5)
        )
    )))
    """;

  svar_def := "var" sdeclname = sexpr ";" =>#
    """
    `(ast_var_decl ,_sr ,(first _2) ,(second _2) none (some ,_4))
     """;

  svar_def := "var" sdeclname ":" stypeexpr = sexpr ";" =>#
    """
    `(ast_var_decl ,_sr ,(first _2) ,(second _2) (some ,_4) (some ,_6))
     """;

  svar_def := "var" sdeclname ":" stypeexpr ";" =>#
    """
    `(ast_var_decl ,_sr ,(first _2) ,(second _2) (some ,_4) none)
     """;
}

//------------------------------------------
syntax macros {
  requires expressions, statements;

  sdirective := smacro_definition =># "_1";
  smacro_definition := "macro" sname "is" sbasic_name_comma_list ";" =>#
    "`(ast_macro_names ,_2 ,_4)";

  // this MUST be next, overrides case with only one name
  smacro_definition := "macro" sname "is" sname ";" =># "`(ast_macro_name ,_2 ,_4)";
  smacro_definition := "macro" "for" sname "in" sbasic_name_comma_list "do" sstatements "done" ";" =>#
    "`(ast_macro_ifor ,_3 ,_5 ,_7)";
  smacro_definition := "macro" "for" sname "in" lpar sbasic_name_comma_list rpar "do" sstatements "done" ";" =>#
    "`(ast_macro_ifor ,_3 ,_6 ,_9)";

  smacro_definition := "macro" sname "is" "new" ";" =># """`(ast_macro_name ,_2 "")""";
  smacro_definition := "macro" "var" sbasic_name_comma_list = sexpr ";" =>#
    "`(ast_macro_var ,_3 ,_5)";
  smacro_definition := "macro" "val" sbasic_name_comma_list = sexpr ";" =>#
    "`(ast_macro_val ,_3 ,_5)";
  smacro_definition := "macro" sbasic_name_comma_list = sexpr ";" =>#
    "`(ast_macro_assign ,_2 ,_4)";
  smacro_definition := "macro" "val" sname "is" sexpr ";" =>#
    "`(ast_macro_vals ,_3 ,(mkl _5))";
  smacro_definition := "macro" "fun" sname smac_arg_list = sexpr ";" =>#
    "`(ast_expr_macro ,_3 ,_4 ,_6)";
  smacro_definition := "macro" "fun" sname smac_arg_list "=>" sexpr ";" =>#
    "`(ast_expr_macro ,_3 ,_4 ,_6)";
  smacro_definition := "macro" "proc" sname smac_arg_list scompound =>#
    "`(ast_stmt_macro ,_3 ,_4 ,_5)";
  smacro_definition := "macro" scompound ";" =># "`(ast_macro_block ,_2)";
  smacro_definition := "macro" "forget" sbasic_name_comma_list ";" =>#
    "`(ast_macro_forget ,_3)";
  smacro_definition := "macro" "forget" ";" =>#
    "`(ast_macro_forget ())";
  smacro_definition := "macro" "goto" sname ";" =># "`(ast_macro_goto ,_3)";
  smacro_definition := "macro" sname ":>" =># "`(ast_macro_label ,_2)";
  smacro_definition := "macro" "if" sexpr "goto" sname ";" =>#
    "`(ast_macro_ifgoto ,_3 ,_5)";
  smacro_definition := "macro" "for" "val" sbasic_name_comma_list "in" sexpr "do" sstatements "done" ";" =>#
    "`(ast_macro_vfor ,_4 ,_6 ,_8)";

  smac_arg:= sname ":" "fun" =># "`(,_1 Expr)";
  smac_arg:= sname ":" "proc" =># "`(,_1 Stmt)";
  smac_arg:= sname ":" "ident" =># "`(,_1 Stmt)";
  smac_arg:= sname =># "`(,_1 Expr)";
  smac_args := smac_arg , smac_args =># "(cons _1 _3)";
  smac_args := smac_arg =># "`(,_1)";
  smac_arg_list := lpar smac_args rpar =># "_2";
  smac_arg_list := lpar rpar =># "()";

  x[sapplication_pri] := "macro" "ctor" sname x[scoercion_pri] =># "`ast_macro_ctor (,_3 ,_4))";
}

//------------------------------------------
syntax cbind {
  requires expressions, statements;

  tstatement:= sbinding_definition =># "_1";
  sbinding_definition :=  sabstract_type =># "_1";
  sbinding_definition :=  sconst_def =># "_1";
  sbinding_definition :=  sbinding_header =># "_1";
  sbinding_definition :=  sexport_statement =># "_1";
   sexport_statement := k"export" "fun" ssuffixed_name "as" sstring ";" =>#
    "`(ast_export_fun ,_sr ,_3 ,_5)";
   sexport_statement := k"export" k"python" "fun" ssuffixed_name "as" sstring ";" =>#
    "`(ast_export_python_fun ,_sr ,_4 ,_6)";
  sexport_statement := k"export" "proc" ssuffixed_name "as" sstring ";" =>#
    "`(ast_export_fun ,_sr ,_3 ,_5)";
  sexport_statement := k"export" "type" lpar sexpr rpar "as" sstring ";" =>#
    "`(ast_export_type ,_sr ,_4 ,_7)";

  sopt_prec := "is" sname =># "_2";
  sopt_prec := sepsilon =># '(quote "")';

  // note: also needed by typeclasses atm for virtual funs
  sfunction_definition := sadjectives sfun_kind sdeclname fun_return_type sopt_cstring sopt_prec srequires_clause ";" =>#
    """
      (let (
        (name (first _3))
        (vs (second _3))
        (kind (cal_funkind _1 _2))
        (t (first _4))
        (traint (second _4))
        (prec _6)
        (reqs (if (memv 'Virtual _1)
          `(rreq_and (rreq_atom (Property_req "virtual")) ,_7)
          _7)
        )
        (ct
          (if (eq? 'none _5)
            (if (memv 'Virtual _1)
              'Virtual
               `(StrTemplate ,(string-append (first _3) "($a)"))
             )
             (second _5))
        )
      )
      (let (
        (reqs
          (if (eq? 'Generator kind)
            `(rreq_and (rreq_atom (Property_req "generator")) ,reqs)
            reqs))
      )
      (let (
        (reqs
          (if (memv 'Lvalue _1)
            `(rreq_and (rreq_atom (Property_req "lvalue")) ,reqs)
            reqs))
      )
      (if (eq? 'ast_arrow (first t))
        (let (
          (argt (caadr t))
          (ret (cadadr t)))
        `(ast_fun_decl ,_sr ,name ,vs ,(mkl2 argt) ,ret ,ct ,reqs ,prec)
        )
        ('ERROR)))))
    """;

  sfunction_definition := "ctor" sname stvarlist ":" stypeexpr sopt_cstring sopt_prec srequires_clause ";" =>#
    """
    (let*
      (
        (name (string-append "_ctor_" _2))
        (vs _3)
        (ret `(ast_name ,_sr ,_2 ()))
        (argt _5)
        (ct
          (if (eq? 'none _6)
            `(StrTemplate ,(string-append _2 "($a)"))
            (second _6)
          )
        )
        (prec _7)
        (reqs _8)
      )
      `(ast_fun_decl ,_sr ,name ,vs ,(mkl2 argt) ,ret ,ct ,reqs ,prec)
    )
    """;

  sabstract_type:= stype_qual* "type" sdeclname = scode_spec srequires_clause ";" =>#
    """
    `(ast_abs_decl ,_sr ,(first _3) ,(second _3) ,_1 ,_5 ,_6)
    """;

  sabstract_type := "callback" "proc" sname ":" stypeexpr srequires_clause ";" =>#
    """
    `(ast_callback_decl ,_sr ,_3 ,(mkl2 _5) ast_void ,_6)
    """;

  sabstract_type := "callback" "fun" sname ":" stypeexpr srequires_clause ";" =>#
    """
    (if (eq? 'ast_arrow (first _5))
      (let*
        (
          (ft (second _5))
          (dom (first ft))
          (cod (second ft))
          (args (mkl2 dom))
        )
      `(ast_callback_decl  ,_sr,_3 ,args ,cod ,_6)
      )
      'ERROR
    )
    """;

  stype_qual := "incomplete" =># "'Incomplete";
  stype_qual := "pod" =># "'Pod";
  stype_qual := "_gc_pointer" =># "'GC_pointer";
  stype_qual := "_gc_type" stypeexpr =># "`(Raw_needs_shape ,_2)";

  sabstract_type:= stype_qual* "ctypes" sbasic_name_comma_list srequires_clause ";" =>#
    "`(ast_ctypes ,_sr ,_3 ,_1 ,_4)";

  sexecutable := sinline_cpp =># "_1";
  sinline_cpp:= "code" scode_spec ";" =># "`(ast_code ,_sr ,_2)";
  sinline_cpp:= "noreturn" "code" scode_spec ";" =># "`(ast_noreturn_code ,_sr ,_3)";

  sexpr_code_prefix := "code" lsqb stypeexpr rsqb =># "_3";
  satom := sexpr_code_prefix sstring =># "`(ast_expr ,_2 ,_1)";
  satom := sexpr_code_prefix sname =># "`(ast_expr ,_2 ,_1)";

  // note: also needed by typeclasses atm for virtual consts
  sconst_def := sadjectives "const" sdeclname ":" stypeexpr = scode_spec srequires_clause ";" =>#
    """
      (let ((reqs (if (memv 'Virtual _1)
        `(rreq_and (rreq_atom (Property_req "virtual")) ,_8)
        _8)))
      `(ast_const_decl ,_sr ,(first _3) ,(second _3) ,_5 ,_7 ,reqs)
      )
    """;

  // note: also needed by typeclasses atm for virtual consts
  sconst_def := sadjectives "const" sdeclname ":" stypeexpr srequires_clause ";" =>#
    """
      (let ((reqs (if (memv 'Virtual _1)
        `(rreq_and (rreq_atom (Property_req "virtual")) ,_6)
        _6)))
      `(ast_const_decl ,_sr ,(first _3) ,(second _3) ,_5 (Str ,(first _3)) ,reqs)
      )
    """;

  // note: also needed by typeclasses atm for virtual procs
  sprocedure_definition := sadjectives sproc_kind sdeclname ":" stypeexpr sopt_cstring srequires_clause ";" =>#
    """
      (let (
        (name (first _3))
        (vs (second _3))
        (kind (cal_funkind _1 _2))
        (t _5)
        (reqs (if (memv 'Virtual _1)
          `(rreq_and (rreq_atom (Property_req "virtual")) ,_7)
          _7)
        )
        (ct
          (if (eq? 'none _6)
            (if (memv 'Virtual _1)
              'Virtual
               `(StrTemplate ,(string-append (first _3) "($a);"))
             )
             (second _6))
        )
      )
      (let (
        (reqs
          (if (eq? 'Generator kind)
            `(rreq_and (rreq_atom (Property_req "generator")) ,reqs)
            reqs))
      )
      (let (
        (argt t)
        (ret 'ast_void))
        `(ast_fun_decl ,_sr ,name ,vs ,(mkl2 argt) ,ret ,ct ,reqs "")
        )))
    """;
}

//------------------------------------------
syntax executable {
  requires statements;
  sexecutable := scall =># "_1";
  sexecutable := ssvc =># "_1";
  sexecutable := sreturn =># "_1";
  sexecutable := sifgoto =># "_1";
  sexecutable := stodo =># "_1";
  sexecutable := sassignment =># "_1";
  sexecutable := sgoto_statement=># "_1";
  sexecutable := slabel_statement =># "_1";

  ssvc := "_svc" sname ";" =># "`(ast_svc ,_sr ,_2)";

  sassignment := sassignexpr ";" =># "_1";

  // a0 <- f (a1, a2, ..)  means f (a0, a1, a2 ..)
  sassignexpr := sexpr "<-" sexpr =>#
    """
    (let* (
      (fl (splitapply _3))
      (f (first fl))
      (a (second fl)))
      (begin
      ;; (display "f=")(display f)
      ;; (display "\\n_1=")(display _1)
      ;; (display "\\na=")(display a)
      ;; (display "\\nnew a=")(display (cons _1 (mkl a)))
      ;; (display "\\n")
      `(ast_call ,_sr ,f ,(cons _1 (mkl a)))))
    """;

  sassignop:= = =># "'_set";
  sassignop:= "<-" =># "'_pset";
  sassignop:= ":=" =># "'_init";

  srmwop:= "+=" =># "'pluseq";
  srmwop:= "-=" =># "'minuseq";
  srmwop:= "*=" =># "'muleq";
  srmwop:= "/=" =># "'diveq";
  srmwop:= "%=" =># "'modeq";
  srmwop:= "<<=" =># "'leftshifteq";
  srmwop:= ">>=" =># "'rightshifteq";
  srmwop:= "^=" =># "'bxoreq";
  srmwop:= "|=" =># "'boreq";
  srmwop:= "&=" =># "'bandeq";
  srmwop:= "~=" =># "'tildeeq";

  sswapop := "<->" =># "'_swap";

  spreincrop:= "++" =># "'pre_incr";
  spreincrop:= "--" =># "'pre_decr";
  spostincrop:= "++" =># "'post_incr";
  spostincrop:= "--" =># "'post_decr";

  slelement := "val" sname =># "`(Val ,_sr ,_2)";
  slelement := "var" sname =># "`(Var ,_sr ,_2)";
  slelement := sname =># "`(Name ,_sr ,_1)";
  slelement := _ =># "`(Skip ,_sr)";
  slelement := lpar slexprs rpar =># "`(List ,_2)";

  stlelement := slelement ":" x[sfactor_pri] =># "`(,_1 (some ,_3))";
  stlelement := slelement =># "`(,_1 none)";

  slexprs := stlelement , slexprs =># "(cons _1 _3)";
  slexprs := stlelement =># "`(,_1)";

  slexpr := slexprs =># """ (if (null? (tail _1)) (first _1) `((List ,_1) none)) """;

  sassignexpr := "def" slexpr = sexpr =># "`(ast_assign ,_sr _set ,_2 ,_4)";

  sassignexpr := sexpr sswapop sexpr =># "`(ast_call ,_sr ,_2 ((ast_ref ,_1) (ast_ref ,_3)))";

  sassignexpr := sexpr sassignop sexpr =># "`(ast_assign ,_sr ,_2 ((Expr ,_sr ,_1) none) ,_3)";
  sassignexpr := sexpr srmwop sexpr =># "`(ast_assign ,_sr ,_2 ((Expr ,_sr ,_1) none) ,_3)";

  sassignexpr := sexpr spostincrop =># "`(ast_call ,_sr ,_2 (ast_ref ,_1))";
  sassignexpr := spreincrop sexpr =># "`(ast_call ,_sr ,_1 (ast_ref ,_2))";

  utstatement := "yield" sexpr =># "`(ast_yield ,_sr ,_2)";
  utstatement := "return" sexpr =># "`(ast_fun_return ,_sr ,_2)";
  tstatement := "return" ";" =># "`(ast_proc_return ,_sr)";
  utstatement := "halt" sstring =># "`(ast_halt ,_sr ,_2)";
  utstatement := "trace" sname sstring =># "`(ast_trace ,_sr ,_2 ,_3)";

  utstatement := "call" sexpr  =># """(cons 'ast_call (cons _sr (splitapply _2)))""";
  utstatement := "jump" sexpr =># """(cons 'ast_jump (cons _sr (splitapply _2)))""";
  //scall := loop sname sexpr ";" =># "`(ast_loop ,_sr ,_2 ,_3)";
  //scall := loop sname ";" =># "`(ast_loop ,_sr ,_2 (ast_tuple,_sr ()))";
  utstatement  := "loop" sname sexpr =># "`(ast_jump ,_sr (ast_name ,_sr ,_2 ()) ,_3)";
  utstatement  := "loop" sname =># "`(ast_jump ,_sr (ast_name ,_sr ,_2 ()) (ast_tuple,_sr ()))";

  utstatement := sexpr =># "(cons 'ast_call (cons _sr (splitapply _1)))";

  tstatement := sname ":>" =># "`(ast_label ,_sr ,_1)";
  tstatement := "goto" sname =># "`(ast_goto ,_sr ,_2)";

  tstatement := "if" sexpr "goto" sname =># "`(ast_ifgoto ,_sr ,_2 ,_4)";
  utstatement := "if" sexpr "return" =># "`(ast_ifreturn ,_sr ,_2)";
  utstatement := "if" sexpr "call" sexpr =>#
    "`(ast_ifdo ,_sr ,_2 (,(cons 'ast_call (cons _sr (splitapply _4))))())";
  tstatement := "if" sexpr "do" sstatements selse_clause "done" =>#
    "`(ast_ifdo ,_sr ,_2 ,_4 ,_5)";
  tstatement := "if" sexpr "do" sstatements "done" =>#
    "`(ast_ifdo ,_sr ,_2 ,_4 ())";

  selif_clause := "elif" sexpr "do" sstatements =># "`(,_2 ,_4)";
  selif_clause := "elif" sexpr "return" ";"? =># "`(,_2 ((ast_proc_return ,_sr)))";
  selif_clause := "elif" sexpr "goto" sname ";"? =># "`(,_2 (ast_goto ,_sr ,_4))";
  selif_clauses := selif_clauses selif_clause =># "(cons _2 _1)";
  selif_clauses := selif_clause =># "`(,_1)";
  selse_clause := selif_clauses "else" sstatements =>#
    """
        (let ((f (lambda (result condthn)
          (let ((cond (first condthn)) (thn (second condthn)))
            `((ast_ifdo ,_sr ,cond ,thn ,result))))))
        (fold_left f _3 _1))
    """;

  selse_clause := "else" sstatements =># "_2";
  selse_clause := selif_clauses =>#
    """
        (let ((f (lambda (result condthn)
          (let ((cond (first condthn)) (thn (second condthn)))
            `((ast_ifdo ,_sr ,cond ,thn ,result))))))
        (fold_left f () _1))
    """;

  tstatement := "break" =># '`(ast_goto ,_sr "break_label")';
  tstatement := "continue" =># '`(ast_goto ,_sr "continue_label")';
  tstatement := "redo" =># '`(ast_goto ,_sr "redo_label")';

  tstatement := "whilst" sexpr "do" sstatements "done" =>#
    """
      `( ast_macro_block ,( append `(
        ( ast_macro_name "break_label" "" )
        ( ast_macro_name "continue_label" "" )
        ( ast_label ,_sr "continue_label" )
        ( ast_unlikely_ifnotgoto ,_sr ,_2 "break_label" ))
        _4
        `(( ast_goto ,_sr "continue_label" )
        ( ast_label ,_sr "break_label" ))
        )
      )
    """;

  tstatement := "until" sexpr "do" sstatements "done" =>#
    """
      `( ast_macro_block ,( append `(
        ( ast_macro_name "break_label" "" )
        ( ast_macro_name "continue_label" "" )
        ( ast_label ,_sr "continue_label" )
        ( ast_unlikely_ifgoto ,_sr ,_2 "break_label" ))
        _4
        `(( ast_goto ,_sr "continue_label" )
        ( ast_label ,_sr "break_label" ))
        )
      )
    """;


  tstatement := "forall" sname "in" sexpr "do" sstatements "done" =>#
    "`(ast_macro_vfor (,_2) ,_4 ,_6)"
  ;

  tstatement := "forall" sname "in" sexpr "upto" sexpr "do" sstatements "done" =>#
    """
      `(ast_macro_block ,( append `(
        (ast_assign ,_sr _set ((Expr ,_sr (ast_name ,_sr ,_2 ())) none) ,_4)
        ( ast_macro_name "break_label" "" )
        ( ast_macro_name "continue_label" "" )
        ( ast_macro_name "redo_label" "" )
        ( ast_label ,_sr "redo_label" )
        ( ast_unlikely_ifnotgoto ,_sr
          (ast_apply ,_sr (le ((ast_name ,_sr ,_2 ()),_6)))
          "break_label"
        ))
        _8
        `(( ast_label ,_sr "continue_label" )
        (ast_call ,_sr pre_incr (ast_ref (ast_name ,_sr ,_2())))
        ( ast_goto ,_sr "redo_label" )
        ( ast_label ,_sr "break_label" ))
       ))
    """;

  tstatement := "forall" sname "in" sexpr "downto" sexpr "do" sstatements "done" =>#
    """
      `(ast_macro_block ,( append `(
        (ast_assign ,_sr _set ((Expr ,_sr (ast_name ,_sr ,_2 ())) none) ,_4)
        ( ast_macro_name "break_label" "" )
        ( ast_macro_name "continue_label" "" )
        ( ast_macro_name "redo_label" "" )
        ( ast_label ,_sr "redo_label" )
        ( ast_unlikely_ifnotgoto ,_sr
          (ast_apply ,_sr (ge ((ast_name ,_sr ,_2 ()) ,_6)))
          "break_label"
        ))
        _8
        `(( ast_label ,_sr "continue_label" )
        ( ast_call ,_sr pre_decr (ast_ref (ast_name ,_sr ,_2 ())))
        ( ast_goto ,_sr "redo_label" )
        ( ast_label ,_sr "break_label" ))
       ))
    """;
}

//------------------------------------------
syntax requirements {
  srequires_clause := "requires" srequirements =># "_2";

  srequires_clause := sepsilon =># "'rreq_true";

  srequirement:= squalified_name =># "`(Named_req ,_1)";
  srequirement :=  "property" sstring =># "`(Property_req ,_2)";
  srequirement :=  "package" scode_spec =># "`(Package_req ,_2)";

  srequirement_atom:= srequirement =># "`(rreq_atom ,_1)";
  srequirement_atom:= lpar srequirements rpar =># "_2";

  srequirement_and:= srequirement_and "and" srequirement_atom =>#
    "`(rreq_and ,_1 ,_3)";
  srequirement_and:= srequirement_atom =># "_1";

  srequirement_or:= srequirement_or "or" srequirement_and =>#
    "`(rreq_or ,_1 ,_3)";
  srequirement_or:= srequirement_and =># "_1";

  srequirements:= srequirements , srequirement_or =>#
    "`(rreq_and ,_1 ,_3)";
  srequirements:= srequirement_or =># "_1";

  srequirement := "body" scode_spec =># "`(Body_req ,_2)";
  srequirement := "header" scode_spec =># "`(Header_req ,_2)";

  scode_spec := sstring =># "`(StrTemplate ,_1)";
  scode_spec := scstring =># "`(Str ,_1)";
  scode_spec := "ident" =># "'Identity";

  sbinding_header := "requires" srequirements ";" =>#
    """`(ast_insert ,_sr "_root" ,dfltvs (Str "") body ,_2)""";

  sbinding_header := sname "requires" srequirements ";" =>#
    """`(ast_insert ,_sr ,_1 ,dfltvs (Str "") body ,_3)""";

  sbinding_header:= "header" scode_spec srequires_clause ";" =>#
    """`(ast_insert ,_sr "_root" ,dfltvs ,_2 header ,_3))""";
  sbinding_header:= "body" scode_spec srequires_clause ";" =>#
    """`(ast_insert ,_sr "_root" ,dfltvs ,_2 body ,_3))""";
  sbinding_header:= "header" = scode_spec srequires_clause ";" =>#
    """`(ast_insert ,_sr "_root" ,dfltvs ,_3 header ,_4))""";
  sbinding_header:= "body" = scode_spec srequires_clause ";" =>#
    """`(ast_insert ,_sr "_root" ,dfltvs ,_3 body ,_4))""";
  sbinding_header:= "header" sdeclname = scode_spec srequires_clause ";" =>#
    """
    `(ast_insert ,_sr ,(first _2) ,(second _2) ,_4 header ,_5)
     """;

  sbinding_header:= "body" sdeclname = scode_spec srequires_clause ";" =>#
    """
    `(ast_insert ,_sr ,(first _2) ,(second _2) ,_4 body ,_5)
     """;
}

//------------------------------------------
syntax type_decls {
  requires statements;

  satom := stypematch =># "_1";

  stype_alias := "typedef" sdeclname = sexpr ";" =>#
    """
    `(ast_type_alias ,_sr ,(first _2) ,(second _2) ,_4)
    """;

  stype_alias := "typedef" "fun" sdeclname stypefun_args ":" stypeexpr "=>" sexpr ";" =>#
    """
    `(mktypefun ,_sr ,(first _3) ,(second _3) ,_4 ,_6 ,_8)
    """;

  stype_alias := "typedef" "fun" sdeclname ":" stypeexpr = stype_matching+ ";" =>#
    """
    (if (eq? 'ast_arrow (first _5))
      (let (
        (argt (caadr _5))
        (ret (cadadr _5))
        (body `(ast_type_match (_a ,_7))))
        (let ((args `(((_a ,argt)))))
      `(mktypefun ,_sr ,(first _3) ,(second _3) ,args ,ret ,body)
      ))
      ('ERROR)
    )
    """;

  stype_matching := vbar sexpr "=>" sexpr =># "`(,_2 ,_4)";

  stypematch := "typematch" sexpr "with" stype_matching+ "endmatch" =>#
    "`(ast_type_match (,_2 ,_4))";

  sstruct_decl := "struct" sdeclname = ? lbrace sstruct_mem_decl * rbrace =>#
    """
    `(ast_struct ,_sr ,(first _2) ,(second _2) ,_5)
     """;

  sstruct_decl := "cstruct" sdeclname = ? lbrace sstruct_mem_decl * rbrace =>#
    """
    `(ast_cstruct ,_sr ,(first _2) ,(second _2) ,_5)
     """;

  sopt_name := sname =># "_1";
  sopt_name := sepsilon =># '""';

  sstruct_decl := "class" sdeclname = ? scompound =>#
    """
    `(ast_class ,_sr ,(first _2) ,(second _2) ,_4)
     """;

  sstruct_decl := "typeclass" sdeclname = ? scompound =>#
    """
    `(ast_typeclass ,_sr ,(first _2) ,(second _2) ,_4)
     """;

  sstruct_decl := "instance" stvarlist squalified_name = ? scompound =>#
    """
    `(ast_instance ,_sr ,_2 ,_3 ,_5)
     """;

  sunion_decl := "union" sdeclname = stype_sum_items2 ";" =>#
    """
    `(ast_union ,_sr ,(first _2) ,(second _2) ,_4)
     """;

  sunion_decl := "union" sdeclname lbrace stype_sum_item1* rbrace =>#
    """
    `(ast_union ,_sr ,(first _2) ,(second _2) ,_4)
     """;

  sunion_decl := senum_decl =># "_1";

  senum_decl := "enum" sdeclname lbrace senum_items rbrace =>#
    """
    `(ast_union ,_sr ,(first _2) ,(second _2) ,_4)
     """;

  senum_decl := "enum" sdeclname = senum_items ";" =>#
    """
    `(ast_union ,_sr ,(first _2) ,(second _2) ,_4)
     """;

  sopt_value := = sinteger =># "`(some ,_2)";
  sopt_value := sepsilon =># "'none";
  senum_item := sname sopt_value =># "`(,_1 ,_2 ,dfltvs ast_void)";
  senum_items := senum_item , senum_items =># "(cons _1 _3)";
  senum_items := senum_item =># "`(,_1)";
  senum_items := sepsilon =># "()";
}

//------------------------------------------
syntax assertions {
  requires statements;
  sexecutable := sassert_statement =># "_1";

  sassert_statement:= "assert" sexpr ";" =># "`(ast_assert ,_sr ,_2)";

  sdeclarative := sassertion =># "_1";

  sassertion := "axiom" sdeclname sfun_arg ":" sexpr ";" =>#
    """
      `(ast_axiom ,_sr ,(first _2) ,(second _2) ,_3 (Predicate ,_5))
    """;

  sassertion := "axiom" sdeclname sfun_arg ":" sexpr = sexpr ";" =>#
    """
      `(ast_axiom ,_sr ,(first _2) ,(second _2) ,_3 (Equation (,_5 ,_7)))
    """;

  sassertion := "lemma" sdeclname sfun_arg ":" sexpr ";" =>#
    """
      `(ast_lemma ,_sr ,(first _2) ,(second _2) ,_3 (Predicate ,_5))
    """;

  sassertion := "lemma" sdeclname sfun_arg ":" sexpr = sexpr ";" =>#
    """
      `(ast_lemma ,_sr ,(first _2) ,(second _2) ,_3 (Equation (,_5 ,_7)))
    """;

  sreduce_args := lpar stypeparameter_comma_list rpar =># "_2";

  sassertion := "reduce" sdeclname sreduce_args ":" sexpr "=>" sexpr ";" =>#
    """
      `(ast_reduce ,_sr ,(first _2) ,(second _2) ,_3 ,_5 ,_7)
    """;
}

//------------------------------------------
syntax namespaces {
  requires statements;
  sopen_decl := "rename" sdeclname = squalified_name ";" =>#
    """
    `(ast_inherit ,_sr ,(first _2) ,(second _2) ,_4)
    """;

  sopen_decl := "rename" "fun" sdeclname = squalified_name ";" =>#
    """
    `(ast_inherit_fun ,_sr ,(first _3) ,(second _3) ,_5)
    """;

  sopen_decl := "inherit" squalified_name ";" =># "`(ast_inject_module ,_sr ,_2)";

  sopen_decl := "open" stvarlist squalified_name ";" =>#
    "`(ast_open ,_sr ,_2 ,_3)";

  sopen_decl := "use" squalified_name ";" =>#
    """
    (let ((name
      (if (eq? (first _2) 'ast_lookup) (cadadr _2)
        (if (eq? (first _2) 'ast_name) (second _2)
        ("ERROR")))))
    `(ast_use ,_sr ,name ,_2))
    """;
  sopen_decl := "use" sname = squalified_name ";" =># "`(ast_use ,_sr ,_2 ,_4)";

  smodule_definition := "module" sdeclname = ? scompound =>#
    """
    `(ast_untyped_module ,_sr ,(first _2) ,(second _2) ,_4)
     """;

  smodule_definition := "open" "module" sdeclname = ? scompound =>#
    """
    `(ast_seq ,_sr (
      (ast_untyped_module ,_sr ,(first _3) ,(second _3) ,_5)
      (ast_open ,_sr ,dfltvs (ast_name ,_sr ,(first _3) ()))))
     """;
}

//------------------------------------------
syntax felix {
  requires
    statements,
    type_decls,
    variables,
    executable,
    assertions,
    namespaces,
    requirements,
    expressions,
    functions,
    patterns,
    cbind,
    macros
  ;
}
