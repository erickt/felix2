%mltop {
}
{

(* parser header *)
exception EndOfInput

open Batteries
open Dyp
open Lexing
open Printf
open Ocs_types
open Sex_types
open Flx_token
open Flx_exceptions

module StringMap = Map.StringMap

type action_t = [`Scheme of string | `None]
type symbol_t = [`Atom of token_t | `Group of dyalt_t list]
and dyalt_t = symbol_t list * Flx_srcref.t * action_t * anote_t

type page_entry_t = [
  | `Nt of string
  | `Subpage of string * page_entry_t list
]

let strip_us s =
  let n = String.length s in
  let x = Buffer.create n in
  for i = 0 to n - 1 do
    match s.[i] with
    | '_' -> ()
    | c -> Buffer.add_char x c
  done;
  Buffer.contents x

let lexeme x = Lexing.lexeme (Dyp.std_lexbuf x)

let getsr dyp =
  let s = dyp.symbol_start_pos() and e = dyp.symbol_end_pos() in
  Flx_srcref.make (
    s.pos_fname,
    s.pos_lnum,
    s.pos_cnum - s.pos_bol + 1,
    e.pos_lnum,
    e.pos_cnum - e.pos_bol)

let incr_lineno lexbuf n = 
  let lexbuf = Dyp.std_lexbuf lexbuf in
  let n = ref n in
  while !n <> 0 do Lexing.new_line lexbuf; decr n done

let lfcount s =
  let n = ref 0 in
  for i = 0 to (String.length s) - 1 do
    if s.[i] = '\n' then incr n
  done;
  !n

(* string parsers *)
let decode_qstring s =
  let n = String.length s in
  Flx_string.unescape (String.sub s 0 (n-1))

let decode_dstring s =
  let n = String.length s in
  Flx_string.unescape (String.sub s 0 (n-1))

let decode_qqqstring s =
  let n = String.length s in
  Flx_string.unescape (String.sub s 0 (n-3))

let decode_dddstring s =
  let n = String.length s in
  Flx_string.unescape (String.sub s 0 (n-3))

let decode_raw_qstring s = let n = String.length s in String.sub s 0 (n-1)
let decode_raw_dstring s = let n = String.length s in String.sub s 0 (n-1)
let decode_raw_qqqstring s = let n = String.length s in String.sub s 0 (n-3)
let decode_raw_dddstring s = let n = String.length s in String.sub s 0 (n-3)

exception Scheme_error of sval

let giveup () = raise Giveup

let sraise s  = raise (Scheme_error s)

let flx_ocs_init env =
  Ocs_env.set_pf0 env giveup "giveup";
  Ocs_env.set_pf1 env sraise "raise"

let init_env () =
  let env = Ocs_top.make_env () in
  flx_ocs_init env;

  let v1 = Ocs_sym.get_symbol "_sr" in
  let g1 = Vglob { g_sym=v1; g_val = Sunbound } in
  Ocs_env.bind_name env v1 g1;

  let v1 = Ocs_sym.get_symbol "_arg" in
  let g1 = Vglob { g_sym=v1; g_val = Sunbound } in
  Ocs_env.bind_name env v1 g1;

  for n = 1 to 20 do
    let v1 = Ocs_sym.get_symbol ("_" ^ string_of_int n) in
    let g1 = Vglob { g_sym=v1; g_val = Sunbound } in
    Ocs_env.bind_name env v1 g1;
  done;
  env

let global_data = {
  handle_stmt = (fun stmt -> ());
  pcounter = ref 1;
  env = init_env ();
  pdebug = ref false;
}

let local_data = {
  Flx_token.dssls = StringMap.empty;
  Flx_token.loaded_dssls = [];
  Flx_token.scm = [];
}

let xsr sr =
  let f, fl, fc, ll, lc = Flx_srcref.to_tuple sr in
  Ocs_misc.make_slist
    Snull
    ((Sint lc) :: (Sint ll) :: (Sint fc) :: (Sint ll) :: (Sstring f) :: [])

let buffer_add_ocs b r = Ocs_print.print_to_buffer b false r

let scheme_lex sr (s:string):sval =
  let sr = Flx_srcref.short_string_of_src sr in
  let inp = Ocs_port.string_input_port s in
  let lex = Ocs_lex.make_lexer inp sr in
  match Ocs_read.read_expr lex with
  | Ocs_types.Seof -> print_endline "END OF FILE?"; Snull
  | v ->  v

let scheme_compile env (s:sval):Ocs_types.code =
  Ocs_compile.compile env s

let scheme_eval (c:Ocs_types.code):sval =
  let th = Ocs_top.make_thread () in
  let term = ref None in
  Ocs_eval.eval th (fun (r:sval) -> term := Some r) c;
  match !term with
  | None -> failwith "Scheme term not returned!"
  | Some r -> r

let scheme_run sr env (s:string):sval =
  let l = scheme_lex sr s in
  let c = scheme_compile env l in
  scheme_eval c

let cal_priority_relation = function
  | `No_prio -> No_priority
  | `Eq_prio p -> Eq_priority p
  | `Less_prio p -> Less_priority p
  | `Lesseq_prio p -> Lesseq_priority p
  | `Greater_prio p -> Greater_priority p
  | `Greatereq_prio p -> Greatereq_priority p

let define_scheme sr dyp dssl_record dssl name prio rhs scm =
  let mapnt name =
    try StringMap.find name dssl_record.privacy
    with Not_found -> name
  in

  let pr_age = !(dyp.global_data.pcounter) in
  incr (dyp.global_data.pcounter);
  let name = mapnt name in

  let rec f o =
    match o with
      | STRING s -> Dyp.Regexp (Dyp.RE_String s)
      | USER_KEYWORD s -> Dyp.Ter "NAME"
      | NONTERMINAL (s,p) ->
          let nt = mapnt s in
          let ntpri = cal_priority_relation p in
          Dyp.Non_ter (nt,ntpri)
      | NAME s -> assert false
      | s -> Dyp.Ter (name_of_token s)
  in
  let cde =
    try
      let l = scheme_lex sr scm in
      let c = scheme_compile dyp.global_data.env l in
      c
    with
    | Ocs_error.Error err
    | Ocs_error.ErrorL (_,err) ->
        failwith ("Error " ^ err ^ " compiling " ^ scm)
  in

  let priority = match prio with
  | `Default -> "default_priority"
  | `Priority p -> p
  in
  let rule = name,(List.map f rhs),priority,[] in

  let action = fun dyp2 avl ->
    match avl,scm with
    (* optimise special case *)
    | [`Obj_sexpr (_,sr,s)],"_1" -> `Obj_sexpr (pr_age,sr,s),[]
    | _ ->
        let age = ref pr_age in
        let b = Buffer.create 200 in

        if !(dyp.global_data.pdebug) then begin
          bprintf b "Reducing Rule %s for %s[%s], scm=%s\n"
            (string_of_int pr_age)
            name
            priority
            scm
        end;

        let env = dyp.global_data.env in
        let rec aux objs syms n =
          match objs, syms with
          | [],[] -> ()
          | [],_ | _,[] -> assert false
          | h1::t1,h2::t2 ->
              let s =
                match h1,h2 with
                | _, `Obj_sexpr (seq,sr,s) -> s
                | k, `Obj_keyword -> Sstring (string_of_token k)
                | (STRING s1 | USER_KEYWORD s1),
                  (`Obj_NAME s2 | `Obj_USER_KEYWORD s2) ->
                    if s1 <> s2 then raise Giveup;
                    Sstring s1
                | STRING _, `Lexeme_matched s -> Sstring s
                | k, _ ->
                    Sstring (string_of_token k)
              in

              if !(dyp.global_data.pdebug) then begin
                bprintf b "Arg %d = %a\n" n buffer_add_ocs s;
              end;

              let v1 = Ocs_sym.get_symbol ("_" ^ string_of_int n) in
              Ocs_env.set_glob env v1 s;
              aux t1 t2 (n+1)
        in
        aux rhs avl 1;

        if !(dyp.global_data.pdebug) then begin
          Buffer.add_string b "End of arguments\n"
        end;

        let sr = getsr dyp2 in

        Ocs_env.set_glob env (Ocs_sym.get_symbol "_sr") (xsr sr);

        let r =
          try scheme_eval cde
          with Ocs_error.Error err | Ocs_error.ErrorL (_,err) ->
            print_string (Buffer.contents b);
            print_string ("Error " ^ err ^ " evaluating " ^ scm);
            failwith "Error evaluating Scheme"
        in
        `Obj_sexpr (!age,sr,r),[]
  in
  rule, action, Bind_to_cons [(name, "Obj_sexpr")]

let extend_grammar dyp (dssl,(name,prio,prod,action,anote,sr)) =
  let m = dyp.local_data in
  let dssl_record = StringMap.find dssl m.dssls in
  define_scheme sr dyp dssl_record dssl name prio prod action

(* -------------------------------------------------------------------------- *)

(* create rules for nt* nt+ and nt? *)
let fixup_suffix_scheme sr pcounter rhs =
  let rec aux inp out extras = match inp with
  | [] -> List.rev out,extras
  | NONTERMINAL (s,p) :: STAR :: t ->
    let x = string_of_int (!pcounter) in incr pcounter;
    let slr = s ^ "__rlist_" ^ x in
    let sl = s ^ "__list_" ^ x in
    let rule0 = slr,`Default,[NONTERMINAL(sl,`No_prio)],"(reverse _1)","",sr in
    let rule1 = sl,`Default,[NONTERMINAL(sl,`No_prio);NONTERMINAL(s,p)],"(cons _2 _1)","",sr in
    let rule2 = sl,`Default,[],"'()","",sr in
    aux t (NONTERMINAL (slr,`No_prio)::out) (rule0::rule1::rule2::extras)

  | NONTERMINAL (s,p) :: PLUS :: t ->
    let x = string_of_int (!pcounter) in incr pcounter;
    let slr = s ^ "__nerlist_" ^ x in
    let sl = s ^ "__nelist_" ^ x in
    let rule0 = slr,`Default,[NONTERMINAL(sl,`No_prio)],"(reverse _1)","",sr in
    let rule1 = sl,`Default,[NONTERMINAL(sl,`No_prio);NONTERMINAL(s,p)],"(cons _2 _1)","",sr in
    let rule2 = sl,`Default,[NONTERMINAL(s,`No_prio)],"`(,_1)","",sr in
    aux t (NONTERMINAL (slr,`No_prio)::out) (rule0::rule1::rule2::extras)

  | NONTERMINAL (s,p) :: QUEST :: t ->
    let x = string_of_int (!pcounter) in incr pcounter;
    let sl = s ^ "__opt_" ^ x in
    let rule1 = sl,`Default,[NONTERMINAL(s,p)],"`(,_1)","",sr in
    let rule2 = sl,`Default,[],"()","",sr in
    aux t (NONTERMINAL (sl,`No_prio)::out) (rule1::rule2::extras)

  | other :: QUEST :: t ->
    let x = string_of_int (!pcounter) in incr pcounter;
    let sl = "__opt_" ^ x in
    let rule1 = sl,`Default,[other],"()","",sr in
    let rule2 = sl,`Default,[],"()","",sr in
    aux t (NONTERMINAL (sl,`No_prio)::out) (rule1::rule2::extras)

  | h :: t -> aux t (h::out) extras
  in aux rhs [] []

let fixup_suffix_string sr pcounter rhs =
  let rec aux inp out extras = match inp with
  | [] -> List.rev out,extras
  | NONTERMINAL (s,p) :: STAR :: t ->
    let x = string_of_int (!pcounter) in incr pcounter;
    let slr = s ^ "__rlist_" ^ x in
    let sl = s ^ "__list_" ^ x in
    let rule0 = slr,`Default,[NONTERMINAL(sl,`No_prio)],"_1","",sr in
    let rule1 = sl,`Default,[NONTERMINAL(sl,`No_prio);NONTERMINAL(s,p)],"(strcat `(,_1 ,_2))","",sr in
    let rule2 = sl,`Default,[],"\"\"","",sr in
    aux t (NONTERMINAL (slr,`No_prio)::out) (rule0::rule1::rule2::extras)

  | NONTERMINAL (s,p) :: PLUS :: t ->
    let x = string_of_int (!pcounter) in incr pcounter;
    let slr = s ^ "__nerlist_" ^ x in
    let sl = s ^ "__nelist_" ^ x in
    let rule0 = slr,`Default,[NONTERMINAL(sl,`No_prio)],"_1","",sr in
    let rule1 = sl,`Default,[NONTERMINAL(sl,`No_prio);NONTERMINAL(s,p)],"(strcat `(,_1 ,_2))","",sr in
    let rule2 = sl,`Default,[NONTERMINAL(s,`No_prio)],"_1","",sr in
    aux t (NONTERMINAL (slr,`No_prio)::out) (rule0::rule1::rule2::extras)

  | NONTERMINAL (s,p) :: QUEST :: t ->
    let x = string_of_int (!pcounter) in incr pcounter;
    let sl = s ^ "__opt_"^x in
    let rule1 = sl,`Default,[NONTERMINAL(s,p)],"_1","",sr in
    let rule2 = sl,`Default,[],"\"\"","",sr in
    aux t (NONTERMINAL (sl,`No_prio)::out) (rule1::rule2::extras)

  | other :: QUEST :: t ->
    let x = string_of_int (!pcounter) in incr pcounter;
    let sl = "__opt_" ^ x in
    let rule1 = sl,`Default,[other],"_1","",sr in
    let rule2 = sl,`Default,[],"\"\"","",sr in
    aux t (NONTERMINAL (sl,`No_prio)::out) (rule1::rule2::extras)

  | h :: t -> aux t (h::out) extras
  in aux rhs [] []

let fixup_suffix sr pcounter kind rhs =
  match kind with
  | `Sval -> fixup_suffix_scheme sr pcounter rhs
  | `String -> fixup_suffix_string sr pcounter rhs

let fixup_prio sr rhs =
  let rec aux inp out = match inp with
  | [] -> List.rev out

  (* Default relation is greater equal *)
  | NAME s :: LSQB _ :: NAME p :: RSQB _ :: t ->
      aux t (NONTERMINAL (s,`Greatereq_prio p)::out)

  | NAME s :: LSQB _ :: LESS _ :: NAME p :: RSQB _ :: t ->
      aux t (NONTERMINAL (s,`Less_prio p)::out)

  | NAME s :: LSQB _ :: LESSEQUAL _ :: NAME p :: RSQB _ :: t ->
      aux t (NONTERMINAL (s,`Lesseq_prio p)::out)

  | NAME s :: LSQB _ :: GREATER _ :: NAME p :: RSQB _ :: t ->
      aux t (NONTERMINAL (s,`Greater_prio p)::out)

  | NAME s :: LSQB _ :: GREATEREQUAL _ :: NAME p :: RSQB _ :: t ->
      aux t (NONTERMINAL (s,`Greatereq_prio p)::out)

  | NAME s :: LSQB _ :: EQUAL _ :: NAME p :: RSQB _ :: t ->
      aux t (NONTERMINAL (s,`Eq_prio p)::out)
   
  | NAME s :: LSQB :: _ ->
      client_error sr "Dangling [ in grammar"
 
  | NAME s ::t ->
      aux t (NONTERMINAL (s,`No_prio)::out)
  | h :: t -> aux t (h::out)
  in aux rhs []

let default_action kind prod =
  let rn = ref 1 in
  let action =
    match kind with
    | `Sval ->
        "`(" ^
        List.fold_left (fun acc _ -> let n = !rn in incr rn;
          (if acc = "" then "" else acc ^ " ") ^ ",_" ^ string_of_int n
        ) "" prod
        ^ ")"

    | `String ->
        "(strcat `(" ^
        List.fold_left (fun acc _ -> let n = !rn in incr rn;
          (if acc = "" then "" else acc ^ " ") ^ ",_" ^ string_of_int n
        ) "" prod
        ^ "))"
  in
  action

let user_expr prod fn : string =
  (* this is a supreme hack .. but it is mandatory because Marshal cannot save
   * an Ocs.sval because it can contain primitive functions *)
  let fn = Ocs_print.string_of_ocs fn in
  let rn = ref 1 in
  let arg =
    let rec aux acc inp = match inp with
    | [] -> acc
    | `Atom (NAME _) :: `Atom LSQB ::
      `Atom (EQUAL | LESS | GREATER | LESSEQUAL | GREATEREQUAL) ::
      `Atom (NAME _) :: `Atom RSQB :: t
    | `Atom (NAME _) :: t ->
        let n = !rn in incr rn;
        aux
        (
          (if acc = "" then "" else acc ^ " ")
          ^ "(Expression_term ,_" ^ string_of_int n ^ ")"
        ) t

    | `Atom (QUEST | PLUS | STAR) :: _
    | `Group _ :: _ ->
        failwith "Production of user expression can't have meta symbols"

    | `Atom k :: t ->
        (* this is really a don't care case .. *)
        let k = string_of_token k in
        incr rn;
        aux
        (
          (if acc = "" then "" else acc ^ " ")
          ^ "(Keyword_term " ^ Flx_string.c_quote_of_string k ^ ")"
        ) t
    in aux "" prod
  in
  let action = "(Apply_term (Expression_term " ^ fn ^ ") (" ^ arg ^ "))" in
  let action = "`(ast_user_expr ,_sr \"dunno\" " ^ action ^ ")" in
  action

let cal_action kind prod action =
  match action with
  | `None -> default_action kind prod
  | `Scheme scm -> scm

let rec flatten sr pcounter kind rhs =
  let rec aux inp out extras = match inp with
  | [] -> List.rev out,extras

  | `Group dyalts :: t ->
      let x = string_of_int (!pcounter) in incr pcounter;
      let sl = "__grp_" ^ x in
      let rules = fixup_alternatives pcounter kind sl `Default dyalts in
      aux t (NONTERMINAL (sl, `No_prio)::out) (rules@extras)

  | `Atom h :: t -> aux t (h::out) extras
  in aux rhs [] []

and fixup_rule sr pcounter kind rhs =
  let rhs,extras = flatten sr pcounter kind rhs in
  let rhs, extras =
    fixup_prio sr rhs,
    List.map begin fun (name,prio,prod,action,anote,sr) ->
      name, prio, fixup_prio sr prod, action, anote, sr
    end extras
  in
  let rhs,extras' = fixup_suffix sr pcounter kind rhs in
  rhs, extras@extras'

and fixup_alternatives pcounter kind name prio dyalts =
  let rules =
    List.fold_left
      (fun rules (rhs,sr,action,anote) ->
        let prod,extras = fixup_rule sr pcounter kind rhs in
        let action = cal_action kind prod action in
        ((name,prio,prod,action,anote,sr) :: extras) @ rules
      )
      [] dyalts
  in
  List.rev rules

let add_rule global_data local_data dssl rule =
  let m = local_data in
  let d = try StringMap.find dssl m.dssls with Not_found -> empty_dssl in

  match rule with
  | `Scheme_rule (privacy,name,prio,kind,dyalts) ->
      let rules = fixup_alternatives
        global_data.pcounter
        kind
        name
        prio
        dyalts
      in
      let rules = List.fold_left
        (fun acc rule -> Flx_list.uniq_add rule acc)
        d.rules
        rules
      in
      let privacy =
        match privacy with
        | `Private ->
            let n = !(global_data.pcounter) in incr (global_data.pcounter);
            let secret = "_"^name^"_"^string_of_int n in
            StringMap.add name secret d.privacy
        | `Public -> d.privacy
      in
      let d = { d with rules = rules; privacy = privacy } in
      let m = { m with dssls = StringMap.add dssl d m.dssls } in
      global_data,m

  | `Requires ls ->
      let d = { d with deps = ls @ d.deps } in
      let m = { m with dssls = StringMap.add dssl d m.dssls } in
      global_data,m

  | `Document (name,s) -> global_data, local_data
  | `Page (name,entries) -> global_data, local_data
  | `Priorities p ->
      let d = { d with prios = p::d.prios } in
      let m = { m with dssls = StringMap.add dssl d m.dssls } in
      global_data, m

(*
let smerge ((oseq,osr,osex),ogd,old as oit) ((nseq,nsr,nsex),ngd,nld as nit) =
   if oseq > nseq then oit
   else if nseq > oseq then nit
   else if Ocs_misc.test_equal osex nsex then oit else begin
     client_error2 osr nsr "AMBIGUITY PARSING, same production!,seq = %d" nseq
   end

let dyp_merge_Obj_sexpr ol =
 match ol with
 | [] -> assert false
 | [ntt,gd,ld] -> [ntt],gd,ld

 | h :: t ->
   match List.fold_left smerge h t with
   ntt,gd,ld -> [ntt],gd,ld

let rec elim_common_prefix x y =
  match x, y with
  | a :: ta, b :: tb ->
    let eq = try a = b with _ -> false in
    if eq then elim_common_prefix ta tb
    else x,y

  | x,y -> x,y

let ssmerge ((xseq,x),xgd,xld as xit) ((yseq,y),ygd,yld as yit) =
  if xseq > yseq then xit
  else if yseq > xseq then yit
  else
    let xsr = Flx_srcref.dummy_sr in
    let ysr = Flx_srcref.dummy_sr in

    (*
    let xsr = src_of_stmt (List.hd x) in
    let ysr = src_of_stmt (List.hd y) in

    let x = List.rev x in
    let y = List.rev y in

    let x,y = elim_common_prefix x y in

    print_endline ("Statements 1 = " ^ catmap "\n----\n" (string_of_statement 1) x);
    print_endline ("Statement 2 = " ^ catmap "\n----\n" (string_of_statement 1) y);
    *)
    client_error2 xsr ysr "AMBIGUITY PARSING TOP LEVEL!"

let dyp_merge_Obj_statement_star ol =
  match ol with
  | []
  | [_] -> assert false
  | h::t ->
      let ntt, gd, ld = List.fold_left ssmerge h t in
      [ntt],gd,ld
      *)
}


/* special */
%token <(Flx_srcref.t * string)> ERRORTOKEN
%token ENDMARKER

/* whitespace and comments */
%token NEWLINE
%token SLOSH

/* literals */
%token <string> NAME
%token <(string * prio_t)> NONTERMINAL
%token <(string * Big_int.big_int)> INTEGER
%token <(string * string )> FLOAT
%token <string> STRING
%token <string> CSTRING
%token <string> FSTRING
%token <string> QSTRING
%token <string> WSTRING
%token <string> USTRING
%token <string> USER_KEYWORD
%token <string list> HASH_INCLUDE_FILES
%token DUMMY

%token QUEST
%constructor Obj_keyword %for QUEST
%token PLUS
%constructor Obj_keyword %for PLUS
%token STAR
%constructor Obj_keyword %for STAR

%token LPAR
%constructor Obj_keyword %for LPAR
%token RPAR
%constructor Obj_keyword %for RPAR

%token LSQB
%constructor Obj_keyword %for LSQB
%token RSQB
%constructor Obj_keyword %for RSQB

%token LBRACE
%constructor Obj_keyword %for LBRACE
%token RBRACE
%constructor Obj_keyword %for RBRACE

%token COMMA
%constructor Obj_keyword %for COMMA
%token VBAR
%constructor Obj_keyword %for VBAR

%token LESS
%constructor Obj_keyword %for LESS
%token GREATER
%constructor Obj_keyword %for GREATER
%token EQUAL
%constructor Obj_keyword %for EQUAL
%token EQEQUAL
%constructor Obj_keyword %for EQEQUAL
%token NOTEQUAL
%constructor Obj_keyword %for NOTEQUAL
%token LESSEQUAL
%constructor Obj_keyword %for LESSEQUAL
%token GREATEREQUAL
%constructor Obj_keyword %for GREATEREQUAL

%token UNDERSCORE
%constructor Obj_keyword %for UNDERSCORE
/* top level entry */
%constructor Obj_sexpr %for sterm

/* predefined major non-terminals */
%constructor Obj_sexpr %for sexpr
%constructor Obj_sexpr %for sstatements tstatement utstatement

/* low level non terminals */
%constructor Obj_sexpr %for sname sliteral

/* literals */
%constructor Obj_sexpr %for sinteger sfloat sstring scstring 
%constructor Obj_sexpr %for strint strfloat strstring 

/* patterns */
%constructor Obj_sexpr %for sintegral

/* tokens replacements for special symbols used in productions */
%constructor Obj_sexpr %for star plus quest sident
%constructor Obj_sexpr %for lbrace rbrace lpar rpar lsqb rsqb
%constructor Obj_sexpr %for ssemi comma colon vbar



/* nothing*/
%constructor Obj_sexpr %for sepsilon
%constructor Obj_sexpr %for strepsilon

%start <local_data_t> compilation_unit

%lexer

/* ====================== REGULAR DEFINITIONS ============================ */
/* special characters */
let quote = '\''
let dquote = '"'
let slosh = '\\'
let linefeed = '\n'
let tab = '\t'
let space = ' '
let formfeed = '\012'
let vtab = '\011'
let carriage_return = '\013'
let underscore = '_'

/* character sets */
let bindigit = ['0'-'1']
let octdigit = ['0'-'7']
let digit = ['0'-'9']
let hexdigit = digit | ['A'-'F'] | ['a'-'f']
let lower = ['a'-'z']
let upper = ['A'-'Z']
/* let letter = lower | upper */
let letter = lower | upper
let hichar = ['\128'-'\255']
let white = space | tab

/* nasty: form control characters */
let form_control = linefeed | carriage_return | vtab | formfeed
let newline_prefix = linefeed | carriage_return
let newline = formfeed | linefeed  | carriage_return linefeed
let hash = '#'

let ordinary = letter | digit | hichar |
  '!' | '$' | '%' | '&' | '(' | ')' | '*' |
  '+' | ',' | '-' | '.' | '/' | ':' | ';' | '<' |
  '=' | '>' | '?' | '@' | '[' | ']' | '^' | '_' |
  '`' | '{' | '|' | '}' | '~'

/* any sequence of these characters makes one or more tokens */
/* MISSING: # should be in here, but can't be supported atm
  because preprocessor # uses a conditional, and just errors
  out if the # isn't at the start of a line .. needs fixing,
  not sure how to fix it
*/

let symchar =
  '!' | '$' | '%' | '&' | '(' | ')' | '*' |
  '+' | ',' | '-' | '.' | '/' | ':' | ';' | '<' |
  '=' | '>' | '?' | '@' | '[' | ']' | '^' |
  '`' | '{' | '|' | '}' | '~' | '#' | '\\'

let printable = ordinary | quote | dquote | slosh | hash

/* identifiers */
let ucn =
    "\\u" hexdigit hexdigit hexdigit hexdigit
  | "\\U" hexdigit hexdigit hexdigit hexdigit hexdigit hexdigit hexdigit hexdigit

let prime = '\''
let idletter = letter | underscore | hichar | ucn
let identifier = idletter (idletter | digit | prime )*

/* integers */
let bin_lit  = '0' ('b' | 'B') (underscore? bindigit) +
let oct_lit  = '0' ('o' | 'O') (underscore? octdigit) +
let dec_lit  = ('0' ('d' | 'D'| "d_" | "D_"))? digit (underscore? digit) *
let hex_lit  = '0' ('x' | 'X') (underscore? hexdigit)  +
let fastint_type_suffix = 't'|'T'|'s'|'S'|'i'|'I'|'l'|'L'|'v'|'V'|"ll"|"LL"
let exactint_type_suffix =
    "i8" | "i16" | "i32" | "i64"
  | "u8" | "u16" | "u32" | "u64"
  | "I8" | "I16" | "I32" | "I64"
  | "U8" | "U16" | "U32" | "U64"

let signind = 'u' | 'U'

let suffix =
    '_'? exactint_type_suffix
  | ('_'? fastint_type_suffix)? ('_'? signind)?
  | ('_'? signind)? ('_'? fastint_type_suffix)?

let int_lit = (bin_lit | oct_lit | dec_lit | hex_lit) suffix

/* floats: Follows ISO C89, except that we allow underscores */
let decimal_string = digit (underscore? digit) *
let hexadecimal_string = hexdigit (underscore? hexdigit) *

let decimal_fractional_constant =
  decimal_string '.' decimal_string?
  | '.' decimal_string

let hexadecimal_fractional_constant =
  ("0x" |"0X")
  (hexadecimal_string '.' hexadecimal_string?
  | '.' hexadecimal_string)

let decimal_exponent = ('E'|'e') ('+'|'-')? decimal_string
let binary_exponent = ('P'|'p') ('+'|'-')? decimal_string

let floating_suffix = 'L' | 'l' | 'F' | 'f' | 'D' | 'd'
let floating_literal =
  (
    decimal_fractional_constant decimal_exponent? |
    hexadecimal_fractional_constant binary_exponent?
  )
  floating_suffix?

/* Python strings */
let qqq = quote quote quote
let ddd = dquote dquote dquote

let escape = slosh _

let dddnormal = ordinary | hash | quote | escape | white | newline
let dddspecial = dddnormal | dquote dddnormal | dquote dquote dddnormal

let qqqnormal = ordinary | hash | dquote | escape | white | newline
let qqqspecial = qqqnormal | quote qqqnormal | quote quote qqqnormal

let raw_dddnormal = ordinary | hash | quote | slosh | white | newline
let raw_dddspecial = raw_dddnormal | dquote raw_dddnormal | dquote dquote raw_dddnormal

let raw_qqqnormal = ordinary | hash | dquote | slosh | space | newline
let raw_qqqspecial = raw_qqqnormal | quote raw_qqqnormal | quote quote raw_qqqnormal

let qstring = (ordinary | hash | dquote | escape | white) * quote
let dstring = (ordinary | hash | quote | escape | white) * dquote
let qqqstring = qqqspecial * qqq
let dddstring = dddspecial * ddd

let raw = 'r' | 'R'
let see = 'c' | 'C'
let rqc = raw see | see raw

let raw_qstring = (ordinary | hash | dquote | escape | white) * quote
let raw_dstring =  (ordinary | hash | quote | escape | white) * dquote

let raw_qqqstring = raw_qqqspecial * qqq
let raw_dddstring = raw_dddspecial * ddd

let not_hash_or_newline = ordinary | quote | dquote | white | slosh
let not_newline = not_hash_or_newline | hash
let quoted_filename = dquote (ordinary | hash | quote | white | slosh)+ dquote


rule parse_qstring = parse
| qstring {
    let s = lexeme lexbuf in
    let n = lfcount s in
    incr_lineno lexbuf n;
    decode_qstring s
  }

and parse_dstring = parse
| dstring {
    let s = lexeme lexbuf in
    let n = lfcount s in
    incr_lineno lexbuf n;
    decode_dstring s
  }

and parse_qqqstring = parse
| qqqstring {
    let s = lexeme lexbuf in
    let n = lfcount s in
    incr_lineno lexbuf n;
    decode_qqqstring s
  }

and parse_dddstring = parse
| dddstring {
    let s = lexeme lexbuf in
    let n = lfcount s in
    incr_lineno lexbuf n;
    decode_dddstring s
  }

/* ----------- RAW STRING -----------------------------------*/
and parse_raw_dstring = parse
| raw_dstring {
    let s = lexeme lexbuf in
    let n = lfcount s in
    incr_lineno lexbuf n;
    decode_raw_dstring s
  }

and parse_raw_qqqstring = parse
| raw_qqqstring {
    let s = lexeme lexbuf in
    let n = lfcount s in
    incr_lineno lexbuf n;
    decode_raw_qqqstring s
  }

and parse_raw_dddstring = parse
| raw_dddstring {
    let s = lexeme lexbuf in
    let n = lfcount s in
    incr_lineno lexbuf n;
    decode_raw_dddstring s
  }

and parse_C_comment count = parse
| "/*"    { parse_C_comment (count+1) lexbuf }
| newline { incr_lineno lexbuf 1; parse_C_comment count lexbuf }
| "*/"    { if count = 1 then () else parse_C_comment (count - 1) lexbuf }
| _       { parse_C_comment count lexbuf }


main lexer =
  "_" -> UNDERSCORE
  "?" -> QUEST
  "(" -> LPAR
  ")" -> RPAR
  "[" -> LSQB
  "]" -> RSQB
  "{" -> LBRACE
  "}" -> RBRACE
  "," -> COMMA
  "+" -> PLUS
  "*" -> STAR
  "=" -> EQUAL
  "==" -> EQEQUAL
  "!=" -> NOTEQUAL
  "|" -> VBAR
  "<" -> LESS
  ">" -> GREATER
  "<=" -> LESSEQUAL
  ">=" -> GREATEREQUAL
  "#!/" -> HASHBANGSLASH

/* eof is not eaten up, so parent will find eof and emit ENDMARKER */
 "//" not_newline * (newline | eof) -> {
      incr_lineno lexbuf 1
  }

 "/*" -> { parse_C_comment 1 lexbuf }

 int_lit -> INTEGER {
      let s = lexeme lexbuf in
      let n = String.length s in
      let converter, first =
        if n>1 && s.[0]='0'
        then
          match s.[1] with
          | 'b' | 'B' -> Flx_string.binbig_int_of_string,2
          | 'o' | 'O' -> Flx_string.octbig_int_of_string,2
          | 'd' | 'D' -> Flx_string.decbig_int_of_string,2
          | 'x' | 'X' -> Flx_string.hexbig_int_of_string,2
          | _         -> Flx_string.decbig_int_of_string,0
        else Flx_string.decbig_int_of_string,0
      in
      let k = ref (n-1) in
      let t =
        if n >= 2 && s.[n-2]='i' && s.[n-1]='8'
        then (k:=n-2; "int8")
        else if n >= 2 && s.[n-2]='u' && s.[n-1]='8'
        then (k:=n-2; "uint8")
        else if n >= 3 && s.[n-3]='i' && s.[n-2]='1' && s.[n-1]='6'
        then (k:=n-3; "int16")
        else if n >= 3 && s.[n-3]='u' && s.[n-2]='1' && s.[n-1]='6'
        then (k:=n-3; "uint16")

        else if n >= 3 && s.[n-3]='i' && s.[n-2]='3' && s.[n-1]='2'
        then (k:=n-3; "int32")
        else if n >= 3 && s.[n-3]='u' && s.[n-2]='3' && s.[n-1]='2'
        then (k:=n-3; "uint32")

        else if n >= 3 && s.[n-3]='i' && s.[n-2]='6' && s.[n-1]='4'
        then (k:=n-3; "int64")
        else if n >= 3 && s.[n-3]='u' && s.[n-2]='6' && s.[n-1]='4'
        then (k:=n-3; "uint64")

        else begin
          let sign = ref "" in
          let typ = ref "int" in
          begin try while !k>first do
            (match s.[!k] with
            | 'u' | 'U' -> sign := "u"
            | 't' | 'T' -> typ := "tiny"
            | 's' | 'S' -> typ := "short"
            | 'i' | 'I' -> typ := "int"
            | 'l' | 'L' ->
              typ :=
                if !typ = "long" then "vlong" else "long"
            | 'v' | 'V' -> typ := "vlong"
            | _ -> raise Not_found
            );
            decr k
          done with _ -> () end;
          incr k;
          !sign ^ !typ
        end
      in
      let d = String.sub s first (!k-first) in
      let v = (converter d) in
      (t, v)
  }

 floating_literal -> FLOAT {
    let str = lexeme lexbuf in
    let n = String.length str in
    let last_char = str.[n-1] in
    match last_char with
    | 'l'|'L' -> "ldouble", strip_us (String.sub str 0 (n-1))
    | 'f'|'F' -> "float", strip_us (String.sub str 0 (n-1))
    | _       -> "double", strip_us str
  }

/* Python strings */
 quote  -> STRING { parse_qstring lexbuf }
 qqq    -> STRING { parse_qqqstring lexbuf }
 dquote -> STRING { parse_dstring lexbuf }
 ddd    -> STRING { parse_dddstring lexbuf }

/* Python raw strings */
 ('r'|'R') qqq    -> STRING { parse_raw_qqqstring lexbuf }
 ('r'|'R') dquote -> STRING { parse_raw_dstring lexbuf }
 ('r'|'R') ddd    -> STRING { parse_raw_dddstring lexbuf }

/* C strings: type char*  */
 ('c'|'C') qqq    -> CSTRING { parse_qqqstring lexbuf }
 ('c'|'C') dquote -> CSTRING { parse_dstring lexbuf }
 ('c'|'C') ddd    -> CSTRING { parse_dddstring lexbuf }

/* raw C strings: type char*  */
 rqc qqq    -> CSTRING { parse_raw_qqqstring lexbuf }
 rqc dquote -> CSTRING { parse_raw_dstring lexbuf }
 rqc ddd    -> CSTRING { parse_raw_dddstring lexbuf }

/* Format strings */
 ('f'|'F') qqq    -> FSTRING { parse_qqqstring lexbuf }
 ('f'|'F') dquote -> FSTRING { parse_dstring lexbuf }
 ('f'|'F') ddd    -> FSTRING { parse_dddstring lexbuf }

/* wide strings */
 ('w' | 'W') qqq    -> WSTRING { parse_qqqstring lexbuf }
 ('w' | 'W') dquote -> WSTRING { parse_dstring lexbuf }
 ('w' | 'W') ddd    -> WSTRING { parse_dddstring lexbuf }

/* UTF32 strings */
 ('u' | 'U') qqq    -> USTRING { parse_qqqstring lexbuf }
 ('u' | 'U') dquote -> USTRING { parse_dstring lexbuf }
 ('u' | 'U') ddd    -> USTRING { parse_dddstring lexbuf }

/* keyword strings */
 ('k' | 'K') qqq    -> USER_KEYWORD { parse_qqqstring lexbuf }
 ('k' | 'K') dquote -> USER_KEYWORD { parse_dstring lexbuf }
 ('k' | 'K') ddd    -> USER_KEYWORD { parse_dddstring lexbuf }

/* name strings */
 ('n' | 'N') qqq    -> NAME { parse_qqqstring lexbuf }
 ('n' | 'N') dquote -> NAME { parse_dstring lexbuf }
 ('n' | 'N') ddd    -> NAME { parse_dddstring lexbuf }


/* this MUST be after strings, so raw strings take precedence
  over identifiers, eg r'x' is a string, not an identifier,
  but x'x' is an identifier .. yucky ..
*/
 identifier -> NAME { Flx_id.utf8_to_ucn (lexeme lexbuf) }

/* whitespace */
 white+ -> { () }

 slosh -> SLOSH

/* end of line */
 newline -> { incr_lineno lexbuf 1 }

/* end of file */
 eof -> ENDMARKER { }

/* Anything else is an error */
 _ -> ERRORTOKEN { lexeme lexbuf }

%parser

compilation_unit:
  | graminit top_statements ENDMARKER { 
    (*
    print_endline ("Returning syntax, loaded dssls = " ^ String.concat ","dyp.last_local_data.loaded_dssls);
    print_endline ("Returning syntax, Schemes = " ^ string_of_int (List.length dyp.last_local_data.scm)); 
    print_endline ("Returning syntax, Dssls = " ^ (StringMap.fold (fun k _ acc -> acc ^ " " ^ k) dyp.last_local_data.dssls ""));
    *)
    dyp.last_local_data }

graminit: @{
    (*
    print_endline "Parsing about to start";
    *)
    let m = dyp.local_data in
    let loaded_dssls = m.loaded_dssls in
    let scm = List.rev m.scm in
    let env = dyp.global_data.env in
(*
print_endline ("Doing scheme .. " ^ string_of_int (List.length scm) ^ " fragments");
*)
    List.iter (fun (sr,s) -> ignore (
       (* print_endline ("Scheme: " ^ s); *)
       try scheme_run sr env s
       with Ocs_error.Error err | Ocs_error.ErrorL (_,err) ->
         print_endline ("Error "^err^" executing " ^s);
         failwith "Error executing SCHEME"
      ))
    scm;
(*
print_endline "Scheme Done .. ";
*)
    (* calculate the transitive closure of DSSL's required *)
    let visited = ref [] in
    let to_install = ref [] in
    let rec cal_install s =
      if List.mem s !visited then ()
      else begin
        visited := s :: !visited;
        let d =
          try StringMap.find s m.dssls
          with Not_found -> failwith ("Can't open syntax " ^ s)
        in
        List.iter cal_install d.deps;
        to_install := s :: !to_install
      end
    in
    List.iter cal_install loaded_dssls;
    let to_install = List.rev (!to_install) in
(*
    print_endline ("Installing " ^ cat "," to_install);
*)
    let rules,prios =
      List.fold_left (fun (acc_rules, acc_prios) dssl ->
      let rules,prios =
        let d =
          try StringMap.find dssl m.dssls
          with Not_found -> failwith ("Can't open syntax " ^ dssl)
        in d.rules,d.prios
      in
      let rules = List.map (fun x -> dssl,x) rules in
      acc_rules @ rules, acc_prios @ prios
      )
      ([],[])
      to_install
    in

    let bindings = ref [] in
    let add_rules = List.map (fun rule ->
      let rule, action, binding = extend_grammar dyp rule in
      bindings := binding :: !bindings;
      rule, action
      ) 
      rules 
    in
    let local_data = { m with loaded_dssls = to_install } in
(*
    print_endline ("Mounting Dssls = " ^ (StringMap.fold (fun k _ acc -> acc ^ " " ^ k) m.dssls ""));
*)
    (),!bindings @ [Add_rules add_rules; Local_data local_data; Relation prios]
  }

tstatement:
  | utstatement ";" @{ $1, [Keep_grammar; Local_data (dyp.last_local_data)] }

/* top level statements only */
top_statements:
 | top_statements tstatement
   @{
      let seq,sr,stmt = $2 in
      begin match stmt with
      | Snull -> ()
      | _ ->
          (* Convert the statement into a s-expression. *)
          dyp.global_data.handle_stmt (Ocs2sex.ocs2sex stmt)
      end;
      (), [Keep_grammar; Local_data (dyp.last_local_data)]
   }

 | { () }

/* inner statements only */
sstatements: 
  | sstatement_star utstatement?
    {
      let _, stmts = $1 in
      let stmts = match $2 with
        | None -> stmts
        | Some (seq,sr,s) ->
          match s with
          | Snull -> stmts
          | _ -> s::stmts
      in
      let stmts = Ocs_misc.make_slist Snull stmts in
      (*
      print_endline "Returning inner statement list";
      *)
      0, Flx_srcref.dummy_sr, stmts
    }

sstatement_star:
 | sstatement_star tstatement
   @{
     let seq,sr,s = $2 in
     (match s with Snull -> $1 | _ ->
     let sseq,stmts = $1 in
     (max seq sseq, (s :: stmts))),
     [Keep_grammar; Local_data (dyp.last_local_data)]
    }
  | { 0,[] }

dyprods:
  | dyprods dyprod { $2 :: $1 }
  | { [] }

opt_private:
  | "private" { `Private }
  | { `Public }

opt_prio:
  | LSQB NAME RSQB { `Priority $2 }
  | { `Default }

pri:
  | NAME { $1 }

prilist:
  | pri LESS prilist { $1 :: $3 }
  | pri { [$1] }

dyprod:
   | opt_private NAME opt_prio ":=" dyalts ";" 
     {
       (*
       print_endline ("RULE " ^ snd $2);
       *)
       `Scheme_rule ($1, $2, $3, `Sval, $5)
     }

   | opt_private NAME opt_prio ":" NAME EQUAL dyalts ";" 
     {
       if $5 <> "string" then raise Giveup;
       (*
       print_endline ("STRING RULE " ^ $2);
       *)
       `Scheme_rule ($1, $2, $3, `String, $7)
     }


   | "requires" basic_name_comma_list ";" 
     {
        let dssls = List.map snd $2 in
       `Requires dssls
     }

   | NAME NAME STRING ";" 
     {
       if $1 <> "explain" then raise Giveup;
       `Document ($2, $3)
     }

   | NAME NAME EQUAL subpage_entries ";" 
     {
       if $1 <> "page" then raise Giveup;
       `Page ($2, $4)
     }

   | NAME prilist ";" 
     {
       if $1 <> "priority" then raise Giveup;
       `Priorities $2
     }

subpage_entry:
  | NAME EQUAL LPAR subpage_entries RPAR { `Subpage ($1, $4) }
  | NAME { `Nt $1 }

subpage_entries:
  | subpage_entry COMMA subpage_entries { $1 :: $3 }
  | subpage_entry { [$1] }

action:
   | STRING { `Scheme $1 }
   | LPAR sexpr RPAR { `Expr $2 }

note:
   | NAME STRING
     {
       if $1 <> "note" then raise Giveup;
       $2
     }
   | { "" }

dyalt:
   | rhs "=>#" action note
     {
       let anote = $4 in
       let prod = $1 in
       let action = $3 in
       let action : action_t =
         match action with
         | `Scheme _ as x -> x
         | `None as x -> x
         | `Expr (_,_,e) ->
           `Scheme (user_expr prod e)
       in
       prod,getsr dyp,action,anote
     }
   | rhs { $1,getsr dyp,`None,"" }

dyaltlist:
   | { [] }
   | VBAR dyalt dyaltlist { $2 :: $3 }

dyalts:
   | dyalt dyaltlist { $1 :: $2 }
   | VBAR dyalt dyaltlist { $2 :: $3 }

rhs:
  | rhs_term { [$1] }
  | rhs_term rhs { $1 :: $2 }

rhs_term :
  | rhs_atom { `Atom $1 }
  | LPAR dyalts RPAR { `Group $2 }

rhs_atom:
  | NAME { NAME $1 } /* arbitrary nonterminal */
  | STRING { STRING $1 } /* the string as an identifier */
  | USER_KEYWORD { USER_KEYWORD $1 } /* user terminal */
  | QUEST { QUEST }
  | PLUS { PLUS }
  | STAR { STAR }
  | LPAR { LPAR }
  | RPAR { RPAR }
  | LSQB { LSQB }
  | RSQB { RSQB }
  | LBRACE { LBRACE }
  | RBRACE { RBRACE }
  | COMMA { COMMA }
  | LESS { LESS }
  | GREATER { GREATER }
  | EQUAL { EQUAL }
  | EQEQUAL { EQEQUAL }
  | NOTEQUAL { NOTEQUAL }
  | LESSEQUAL { LESSEQUAL }
  | GREATEREQUAL { GREATEREQUAL }
  | UNDERSCORE { UNDERSCORE }

utstatement:
  | "SCHEME" STRING 
    @{
      let sr = getsr dyp in
      let s = $2 in
      let failwith x = print_endline ("Evaluating " ^ s); failwith x in
      (*
      let env = Ocs_env.env_copy dyp.local_data.env in
      *)
      let env = dyp.global_data.env in
      ignore (
        try scheme_run sr env s
        with Ocs_error.Error err | Ocs_error.ErrorL (_,err) ->
          print_endline ("Error "^err^" executing " ^s);
          failwith "Error executing SCHEME");

      let local_data = { dyp.local_data with scm = (sr,s) :: dyp.local_data.scm } in
      (0, sr, Snull), [Local_data local_data]
    }

  | "open" "syntax" basic_name_comma_list
    @{
      (*
      print_endline "Opening syntax extensions";
      *)
      let sr = getsr dyp in
      let dssls = List.map snd $3 in
(*
      print_endline ("Parsed open of syntax extensions " ^ String.concat "," dssls);
*)
      let m = dyp.local_data in

      (* calculate the transitive closure of DSSL's required
         minus those already installed
      *)
      let installed = m.loaded_dssls in
      let visited = ref [] in
      let to_install = ref [] in
      let rec cal_install s =
        if List.mem s installed or List.mem s !visited then ()
        else begin
          visited := s :: !visited;
          let d =
            try StringMap.find s m.dssls
            with Not_found -> failwith ("Can't open syntax " ^ s)
          in
          List.iter cal_install d.deps;
          to_install := s :: !to_install
        end
      in
      List.iter cal_install dssls
      ;
      let to_install = List.rev (!to_install) in
(*
      print_endline ("Installing " ^ cat "," to_install);
*)
      let rules,prios =
        List.fold_left (fun (acc_rules, acc_prios) dssl ->
        let rules,prios =
          let d =
            try StringMap.find dssl m.dssls
            with Not_found -> failwith ("Can't open syntax " ^ dssl)
          in d.rules,d.prios
        in
        let rules = List.map (fun x -> dssl,x) rules in
        acc_rules @ rules, acc_prios @ prios
        )
        ([],[])
        to_install
      in

      let bindings = ref [] in
      let add_rules = List.map begin fun rule ->
        let rule, action, binding = extend_grammar dyp rule in
        bindings := binding :: !bindings;
        rule, action
      end rules in
(*
      print_endline "Prepared nu grammar rules to yield to Dypgen";
*)
      let local_data = { m with loaded_dssls = to_install @ m.loaded_dssls } in
      (0, sr, Snull),
      !bindings @ [Add_rules add_rules; Local_data local_data; Relation prios]
    }

tstatement:
  | "syntax" NAME LBRACE dyprods RBRACE
    @{
      (* NOTE ORDER!! dyprods is reversed, but the fold reverses it again *)
      let sr = getsr dyp in
      let dssl = $2 in
      let m = dyp.local_data in
      let m =
        if StringMap.mem dssl m.dssls then m
        else {m with dssls=StringMap.add dssl empty_dssl m.dssls}
      in
      let global_data,local_data =
        List.fold_left
          (fun (g,l) x -> add_rule g l dssl x)
          (dyp.global_data, m)
          $4
      in
      (* This cal tries to avoid gratutions mods to global/local data by
       * checking for physical equality. Note changes to any embedded mutable
       * data structure propagate anyhow. *)
      let mods =
        (if dyp.global_data != global_data
          then [Global_data global_data] else [])
        @
        (if dyp.local_data != local_data then [Local_data local_data] else [])
      in
      (0, sr, Snull), mods
    }

sexpr: | DUMMY { 0, Flx_srcref.dummy_sr, Snull }

/* identifiers which aren't keywords */
sname: NAME { 0, getsr dyp, Sstring $1 }

/*
replacements for * + and ? to be used in productions,
since these symbols have special meansings as
list, non-empty list, and optional respectively
*/
star: STAR { 0, getsr dyp, Snull }
plus: PLUS { 0, getsr dyp, Snull }
quest: QUEST { 0, getsr dyp, Snull }

lbrace: LBRACE { 0, getsr dyp, Snull }
rbrace: RBRACE { 0, getsr dyp, Snull }
lpar: LPAR { 0, getsr dyp, Snull }
rpar: RPAR { 0, getsr dyp, Snull }
lsqb: LSQB { 0, getsr dyp, Snull }
rsqb: RSQB { 0, getsr dyp, Snull }

comma: COMMA { 0, getsr dyp, Snull }
vbar: VBAR { 0, getsr dyp, Snull }

/*
a definite non-terminal for a sequence of no tokens,
since the production syntax cannot parse an empty
production at the moment
*/
sepsilon: | { 0, Flx_srcref.dummy_sr, Snull }
strepsilon: | { 0, Flx_srcref.dummy_sr, Sstring "" }

sinteger:
  | INTEGER
    {
      let t, v = $1 in
      0, getsr dyp, Sbigint v
    }

strint:
  | INTEGER
    {
      let t, v = $1 in
      let s = Big_int.string_of_big_int v in
      0, getsr dyp, Sstring s
    }

sfloat:
  | FLOAT
    {
      let t, v = $1 in
      let x = Sstring t::Sstring v::[] in
      let x = Ocs_misc.make_slist Snull (List.rev x) in
      0, getsr dyp, x
    }

strfloat:
  | FLOAT
    {
      let t, v = $1 in
      0, getsr dyp, Sstring v
    }


sintegral:
  | INTEGER
    {
      let t, v = $1 in
      let i = Sstring t :: Sbigint v :: [] in
      let x = Ocs_misc.make_slist Snull (List.rev i) in
      0, getsr dyp, x
    }
  | "-" INTEGER
    {
      let t, v = $2 in
      let v = Big_int.minus_big_int v in
      let i = Sstring t :: Sbigint v :: [] in
      let x = Ocs_misc.make_slist Snull (List.rev i) in
      0, getsr dyp, x
    }

sstring:
  | STRING { 0, getsr dyp, Sstring $1 }

strstring:
  | STRING { 0, getsr dyp, Sstring (Flx_string.c_quote_of_string $1) }

scstring:
  | CSTRING { 0, getsr dyp, Sstring $1 }


sliteral:
  | INTEGER
    {
      let t, v = $1 in
      let sr = getsr dyp in
      let v = Big_int.string_of_big_int v in
      let alit = Ocs_sym.get_symbol "ast_literal" in
      let aint = Ocs_sym.get_symbol "ast_int" in
      let i = aint :: Sstring t :: Sstring v :: [] in
      let i = Ocs_misc.make_slist Snull (List.rev i) in
      let x = alit :: xsr sr :: i :: [] in
      let x = Ocs_misc.make_slist Snull (List.rev x) in
      0, sr, x
    }

  | FLOAT
    {
      let t, v = $1 in
      let sr = getsr dyp in
      let alit = Ocs_sym.get_symbol "ast_literal" in
      let afloat = Ocs_sym.get_symbol "ast_float" in
      let i = afloat :: Sstring t :: Sstring v :: [] in
      let i = Ocs_misc.make_slist Snull (List.rev i) in
      let x = alit :: xsr sr :: i :: [] in
      let x = Ocs_misc.make_slist Snull (List.rev x) in
      0, sr, x
    }

  | STRING
    {
      let s = $1 in
      let sr = getsr dyp in
      let alit = Ocs_sym.get_symbol "ast_literal" in
      let astring = Ocs_sym.get_symbol "ast_string" in
      let i = astring :: Sstring s :: [] in
      let i = Ocs_misc.make_slist Snull (List.rev i) in
      let x = alit :: xsr sr :: i :: [] in
      let x = Ocs_misc.make_slist Snull (List.rev x) in
      0, sr, x
   }

  | WSTRING
    {
      let s = $1 in
      let sr = getsr dyp in
      let alit = Ocs_sym.get_symbol "ast_literal" in
      let astring = Ocs_sym.get_symbol "ast_wstring" in
      let i = astring :: Sstring s :: [] in
      let i = Ocs_misc.make_slist Snull (List.rev i) in
      let x = alit :: xsr sr :: i :: [] in
      let x = Ocs_misc.make_slist Snull (List.rev x) in
      0, sr, x
    }

  | USTRING
    {
      let s = $1 in
      let sr = getsr dyp in
      let alit = Ocs_sym.get_symbol "ast_literal" in
      let astring = Ocs_sym.get_symbol "ast_ustring" in
      let i = astring :: Sstring s :: [] in
      let i = Ocs_misc.make_slist Snull (List.rev i) in
      let x = alit :: xsr sr :: i :: [] in
      let x = Ocs_misc.make_slist Snull (List.rev x) in
      0, sr, x
    }

  | CSTRING
    {
      let s = $1 in
      let sr = getsr dyp in
      let alit = Ocs_sym.get_symbol "ast_literal" in
      let astring = Ocs_sym.get_symbol "ast_cstring" in
      let i = astring :: Sstring s :: [] in
      let i = Ocs_misc.make_slist Snull (List.rev i) in
      let x = alit :: xsr sr :: i :: [] in
      let x = Ocs_misc.make_slist Snull (List.rev x) in
      0, sr, x
    }

  | QSTRING
    {
      let s = $1 in
      let qstring = Ocs_sym.get_symbol "ast_interpolate" in
      let x = qstring :: Sstring s :: [] in
      let x = Ocs_misc.make_slist Snull (List.rev x) in
      0, getsr dyp, x
    }

  | FSTRING
    {
      let s = $1 in
      let fstring = Ocs_sym.get_symbol "ast_vsprintf" in
      let x = fstring :: Sstring s :: [] in
      let x = Ocs_misc.make_slist Snull (List.rev x) in
      0, getsr dyp, x
    }

basic_name:
  | NAME { getsr dyp, $1 }

basic_name_comma_list:
  | basic_name COMMA basic_name_comma_list { $1 :: $3 }
  | basic_name { [$1] }
  | { [] }

epsilon: | { () }

%%

{
let dyphack (ls : ( 'a * string) list) : 'a =
  match ls with
  | [x,_] -> x
  | _ -> failwith "Dypgen parser failed"

let parse_lexbuf (handle_stmt, init, old_local_data) lexbuf =
  let show_error () =
    let b = (Dyp.std_lexbuf lexbuf) in
    let file = b.lex_start_p.pos_fname in
    let start_line = b.lex_start_p.pos_lnum in
    let start_col = b.lex_start_p.pos_cnum - b.lex_start_p.pos_bol + 1 in
    let end_line = b.lex_curr_p.pos_lnum in
    let end_col = b.lex_curr_p.pos_cnum - b.lex_start_p.pos_bol in
    let sr = Flx_srcref.make (file, start_line, start_col, end_line, end_col) in
    print_endline (Flx_srcref.long_string_of_src sr);
  in

  (* Make the init a reference so that our handle_stmt function can update
   * it. *)
  let init = ref init in
  let local_data =
    try
      dyphack (compilation_unit
        ~local_data:old_local_data
        ~global_data: { global_data with
          handle_stmt = fun stmt -> init := handle_stmt stmt !init; }
        lexbuf)
    with
    | Failure s ->
        if Printexc.backtrace_status () then begin
          print_endline (Printexc.get_backtrace ());
        end;
        print_endline ("Parse fail " ^ s);
        show_error();

        parse_error "Failure \"%s\" parsing file" s

    | Flx_exceptions.ClientError (sr :: _, s) as error ->
        if Printexc.backtrace_status () then begin
          print_endline (Printexc.get_backtrace ());
        end;

        print_endline "Parse fail";
        print_endline (Flx_srcref.long_string_of_src sr);
        raise error

    | Dyp.Syntax_error as error ->
        show_error();
        raise error

    | Dyp.Bad_constructor (nt, ctor1, ctor2) ->
        let s = sprintf "Bad constructor '%s' and '%s' for nonterminal '%s'"
          ctor1
          ctor2
          nt
        in
        print_endline s;
        failwith s
  in
  handle_stmt, !init, local_data

let make_parser_state handle_stmt init = handle_stmt, init, local_data

let parser_data (handle_stmt, init, local_data) = init

let parse_channel ?(name="<channel>") parser_state channel =
  let lexbuf = Dyp.from_channel (pp ()) channel in
  Dyp.set_fname lexbuf name;
  parse_lexbuf parser_state lexbuf

let parse_file ?(include_dirs=[]) parser_state name =
  let name = Flx_filesys.find_file ~include_dirs name in
  Flx_filesys.with_file_in name (parse_channel ~name parser_state)

let parse_string ?(name="<string>") parser_state str =
  let lexbuf = Dyp.from_string (pp ()) str in
  Dyp.set_fname lexbuf name;
  parse_lexbuf parser_state lexbuf

let parse_function ?(name="<function>") parser_state f =
  let lexbuf = Dyp.from_function (pp ()) f in
  parse_lexbuf parser_state lexbuf
}
